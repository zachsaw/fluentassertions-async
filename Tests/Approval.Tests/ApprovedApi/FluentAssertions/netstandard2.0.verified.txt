[assembly: System.Reflection.AssemblyMetadata("RepositoryUrl", "https://github.com/fluentassertions/fluentassertions")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(@"Benchmarks, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d25ff515c85b13ba08f61d466cff5d80a7f28ba197bbf8796085213e7a3406f970d2a4874932fed35db546e89af2da88c194bf1b7f7ac70de7988c78406f7629c547283061282a825616eb7eb48a9514a7570942936020a9bb37dca9ff60b778309900851575614491c6d25018fadb75828f4c7a17bf2d7dc86e7b6eafc5d8f")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(@"FluentAssertionsAsync.Equivalency.Specs, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d25ff515c85b13ba08f61d466cff5d80a7f28ba197bbf8796085213e7a3406f970d2a4874932fed35db546e89af2da88c194bf1b7f7ac70de7988c78406f7629c547283061282a825616eb7eb48a9514a7570942936020a9bb37dca9ff60b778309900851575614491c6d25018fadb75828f4c7a17bf2d7dc86e7b6eafc5d8f")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(@"FluentAssertionsAsync.Specs, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d25ff515c85b13ba08f61d466cff5d80a7f28ba197bbf8796085213e7a3406f970d2a4874932fed35db546e89af2da88c194bf1b7f7ac70de7988c78406f7629c547283061282a825616eb7eb48a9514a7570942936020a9bb37dca9ff60b778309900851575614491c6d25018fadb75828f4c7a17bf2d7dc86e7b6eafc5d8f")]
namespace FluentAssertionsAsync
{
    public class AggregateExceptionExtractor : FluentAssertionsAsync.Specialized.IExtractExceptions
    {
        public AggregateExceptionExtractor() { }
        public System.Collections.Generic.IEnumerable<T> OfType<T>(System.Exception actualException)
            where T : System.Exception { }
    }
    public class AndConstraint<T>
    {
        public AndConstraint(T parentConstraint) { }
        public T And { get; }
    }
    public class AndWhichConstraint<TParentConstraint, TMatchedElement> : FluentAssertionsAsync.AndConstraint<TParentConstraint>
    {
        public AndWhichConstraint(TParentConstraint parentConstraint, System.Collections.Generic.IEnumerable<TMatchedElement> matchedConstraint) { }
        public AndWhichConstraint(TParentConstraint parentConstraint, TMatchedElement matchedConstraint) { }
        public TMatchedElement Subject { get; }
        public TMatchedElement Which { get; }
    }
    public static class AssertionExtensions
    {
        public static TTo As<TTo>(this object subject) { }
        public static System.Func<System.Threading.Tasks.Task> Awaiting<T>(this T subject, System.Func<T, System.Threading.Tasks.Task> action) { }
        public static System.Func<System.Threading.Tasks.Task> Awaiting<T>(this T subject, System.Func<T, System.Threading.Tasks.ValueTask> action) { }
        public static System.Func<System.Threading.Tasks.Task<TResult>> Awaiting<T, TResult>(this T subject, System.Func<T, System.Threading.Tasks.Task<TResult>> action) { }
        public static System.Func<System.Threading.Tasks.Task<TResult>> Awaiting<T, TResult>(this T subject, System.Func<T, System.Threading.Tasks.ValueTask<TResult>> action) { }
        public static System.Action Enumerating(this System.Func<System.Collections.IEnumerable> enumerable) { }
        public static System.Action Enumerating<T>(this System.Func<System.Collections.Generic.IEnumerable<T>> enumerable) { }
        public static System.Action Enumerating<T, TResult>(this T subject, System.Func<T, System.Collections.Generic.IEnumerable<TResult>> enumerable) { }
        public static FluentAssertionsAsync.Specialized.ExecutionTime ExecutionTime(this System.Func<System.Threading.Tasks.Task> action) { }
        public static FluentAssertionsAsync.Specialized.ExecutionTime ExecutionTime(this System.Action action, FluentAssertionsAsync.Common.StartTimer createTimer = null) { }
        public static FluentAssertionsAsync.Specialized.MemberExecutionTime<T> ExecutionTimeOf<T>(this T subject, System.Linq.Expressions.Expression<System.Action<T>> action, FluentAssertionsAsync.Common.StartTimer createTimer = null) { }
        public static System.Action Invoking<T>(this T subject, System.Action<T> action) { }
        public static System.Func<TResult> Invoking<T, TResult>(this T subject, System.Func<T, TResult> action) { }
        public static FluentAssertionsAsync.Specialized.ExecutionTimeAssertions Should(this FluentAssertionsAsync.Specialized.ExecutionTime executionTime) { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should(this FluentAssertionsAsync.Specialized.ExecutionTimeAssertions _) { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should(this FluentAssertionsAsync.Specialized.TaskCompletionSourceAssertionsBase _) { }
        public static FluentAssertionsAsync.Types.MethodInfoSelectorAssertions Should(this FluentAssertionsAsync.Types.MethodInfoSelector methodSelector) { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should(this FluentAssertionsAsync.Types.MethodInfoSelectorAssertions _) { }
        public static FluentAssertionsAsync.Types.PropertyInfoSelectorAssertions Should(this FluentAssertionsAsync.Types.PropertyInfoSelector propertyInfoSelector) { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should(this FluentAssertionsAsync.Types.PropertyInfoSelectorAssertions _) { }
        public static FluentAssertionsAsync.Types.TypeSelectorAssertions Should(this FluentAssertionsAsync.Types.TypeSelector typeSelector) { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should(this FluentAssertionsAsync.Types.TypeSelectorAssertions _) { }
        public static FluentAssertionsAsync.Specialized.ActionAssertions Should(this System.Action action) { }
        public static FluentAssertionsAsync.Collections.StringCollectionAssertions Should(this System.Collections.Generic.IEnumerable<string> @this) { }
        public static FluentAssertionsAsync.Primitives.DateTimeAssertions Should(this System.DateTime actualValue) { }
        public static FluentAssertionsAsync.Primitives.NullableDateTimeAssertions Should(this System.DateTime? actualValue) { }
        public static FluentAssertionsAsync.Primitives.DateTimeOffsetAssertions Should(this System.DateTimeOffset actualValue) { }
        public static FluentAssertionsAsync.Primitives.NullableDateTimeOffsetAssertions Should(this System.DateTimeOffset? actualValue) { }
        public static FluentAssertionsAsync.Specialized.NonGenericAsyncFunctionAssertions Should(this System.Func<System.Threading.Tasks.Task> action) { }
        public static FluentAssertionsAsync.Primitives.GuidAssertions Should(this System.Guid actualValue) { }
        public static FluentAssertionsAsync.Primitives.NullableGuidAssertions Should(this System.Guid? actualValue) { }
        public static FluentAssertionsAsync.Streams.BufferedStreamAssertions Should(this System.IO.BufferedStream actualValue) { }
        public static FluentAssertionsAsync.Streams.StreamAssertions Should(this System.IO.Stream actualValue) { }
        public static FluentAssertionsAsync.Primitives.HttpResponseMessageAssertions Should(this System.Net.Http.HttpResponseMessage actualValue) { }
        public static FluentAssertionsAsync.Types.AssemblyAssertions Should(this System.Reflection.Assembly assembly) { }
        public static FluentAssertionsAsync.Types.ConstructorInfoAssertions Should(this System.Reflection.ConstructorInfo constructorInfo) { }
        public static FluentAssertionsAsync.Types.MethodInfoAssertions Should(this System.Reflection.MethodInfo methodInfo) { }
        public static FluentAssertionsAsync.Types.PropertyInfoAssertions Should(this System.Reflection.PropertyInfo propertyInfo) { }
        public static FluentAssertionsAsync.Primitives.SimpleTimeSpanAssertions Should(this System.TimeSpan actualValue) { }
        public static FluentAssertionsAsync.Primitives.NullableSimpleTimeSpanAssertions Should(this System.TimeSpan? actualValue) { }
        public static FluentAssertionsAsync.Types.TypeAssertions Should(this System.Type subject) { }
        public static FluentAssertionsAsync.Xml.XAttributeAssertions Should(this System.Xml.Linq.XAttribute actualValue) { }
        public static FluentAssertionsAsync.Xml.XDocumentAssertions Should(this System.Xml.Linq.XDocument actualValue) { }
        public static FluentAssertionsAsync.Xml.XElementAssertions Should(this System.Xml.Linq.XElement actualValue) { }
        public static FluentAssertionsAsync.Primitives.BooleanAssertions Should(this bool actualValue) { }
        public static FluentAssertionsAsync.Primitives.NullableBooleanAssertions Should(this bool? actualValue) { }
        public static FluentAssertionsAsync.Numeric.NumericAssertions<byte> Should(this byte actualValue) { }
        public static FluentAssertionsAsync.Numeric.NullableNumericAssertions<byte> Should(this byte? actualValue) { }
        public static FluentAssertionsAsync.Numeric.NumericAssertions<decimal> Should(this decimal actualValue) { }
        public static FluentAssertionsAsync.Numeric.NullableNumericAssertions<decimal> Should(this decimal? actualValue) { }
        public static FluentAssertionsAsync.Numeric.NumericAssertions<double> Should(this double actualValue) { }
        public static FluentAssertionsAsync.Numeric.NullableNumericAssertions<double> Should(this double? actualValue) { }
        public static FluentAssertionsAsync.Numeric.NumericAssertions<float> Should(this float actualValue) { }
        public static FluentAssertionsAsync.Numeric.NullableNumericAssertions<float> Should(this float? actualValue) { }
        public static FluentAssertionsAsync.Numeric.NumericAssertions<int> Should(this int actualValue) { }
        public static FluentAssertionsAsync.Numeric.NullableNumericAssertions<int> Should(this int? actualValue) { }
        public static FluentAssertionsAsync.Numeric.NumericAssertions<long> Should(this long actualValue) { }
        public static FluentAssertionsAsync.Numeric.NullableNumericAssertions<long> Should(this long? actualValue) { }
        public static FluentAssertionsAsync.Primitives.ObjectAssertions Should(this object actualValue) { }
        public static FluentAssertionsAsync.Numeric.NumericAssertions<sbyte> Should(this sbyte actualValue) { }
        public static FluentAssertionsAsync.Numeric.NullableNumericAssertions<sbyte> Should(this sbyte? actualValue) { }
        public static FluentAssertionsAsync.Numeric.NumericAssertions<short> Should(this short actualValue) { }
        public static FluentAssertionsAsync.Numeric.NullableNumericAssertions<short> Should(this short? actualValue) { }
        public static FluentAssertionsAsync.Primitives.StringAssertions Should(this string actualValue) { }
        public static FluentAssertionsAsync.Numeric.NumericAssertions<uint> Should(this uint actualValue) { }
        public static FluentAssertionsAsync.Numeric.NullableNumericAssertions<uint> Should(this uint? actualValue) { }
        public static FluentAssertionsAsync.Numeric.NumericAssertions<ulong> Should(this ulong actualValue) { }
        public static FluentAssertionsAsync.Numeric.NullableNumericAssertions<ulong> Should(this ulong? actualValue) { }
        public static FluentAssertionsAsync.Numeric.NumericAssertions<ushort> Should(this ushort actualValue) { }
        public static FluentAssertionsAsync.Numeric.NullableNumericAssertions<ushort> Should(this ushort? actualValue) { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should<TAssertions>(this FluentAssertionsAsync.Primitives.BooleanAssertions<TAssertions> _)
            where TAssertions : FluentAssertionsAsync.Primitives.BooleanAssertions<TAssertions> { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should<TAssertions>(this FluentAssertionsAsync.Primitives.DateTimeAssertions<TAssertions> _)
            where TAssertions : FluentAssertionsAsync.Primitives.DateTimeAssertions<TAssertions> { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should<TAssertions>(this FluentAssertionsAsync.Primitives.DateTimeOffsetAssertions<TAssertions> _)
            where TAssertions : FluentAssertionsAsync.Primitives.DateTimeOffsetAssertions<TAssertions> { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should<TAssertions>(this FluentAssertionsAsync.Primitives.DateTimeOffsetRangeAssertions<TAssertions> _)
            where TAssertions : FluentAssertionsAsync.Primitives.DateTimeOffsetAssertions<TAssertions> { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should<TAssertions>(this FluentAssertionsAsync.Primitives.DateTimeRangeAssertions<TAssertions> _)
            where TAssertions : FluentAssertionsAsync.Primitives.DateTimeAssertions<TAssertions> { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should<TAssertions>(this FluentAssertionsAsync.Primitives.GuidAssertions<TAssertions> _)
            where TAssertions : FluentAssertionsAsync.Primitives.GuidAssertions<TAssertions> { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should<TAssertions>(this FluentAssertionsAsync.Primitives.SimpleTimeSpanAssertions<TAssertions> _)
            where TAssertions : FluentAssertionsAsync.Primitives.SimpleTimeSpanAssertions<TAssertions> { }
        public static FluentAssertionsAsync.Collections.GenericCollectionAssertions<T> Should<T>(this System.Collections.Generic.IEnumerable<T> actualValue) { }
        public static FluentAssertionsAsync.Specialized.GenericAsyncFunctionAssertions<T> Should<T>(this System.Func<System.Threading.Tasks.Task<T>> action) { }
        public static FluentAssertionsAsync.Specialized.FunctionAssertions<T> Should<T>(this System.Func<T> func) { }
        public static FluentAssertionsAsync.Numeric.ComparableTypeAssertions<T> Should<T>(this System.IComparable<T> comparableValue) { }
        public static FluentAssertionsAsync.Specialized.TaskCompletionSourceAssertions<T> Should<T>(this System.Threading.Tasks.TaskCompletionSource<T> tcs) { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should<TSubject, TAssertions>(this FluentAssertionsAsync.Numeric.NumericAssertions<TSubject, TAssertions> _)
            where TSubject :  struct, System.IComparable<TSubject>
            where TAssertions : FluentAssertionsAsync.Numeric.NumericAssertions<TSubject, TAssertions> { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should<TEnum, TAssertions>(this FluentAssertionsAsync.Primitives.EnumAssertions<TEnum, TAssertions> _)
            where TEnum :  struct, System.Enum
            where TAssertions : FluentAssertionsAsync.Primitives.EnumAssertions<TEnum, TAssertions> { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should<TSubject, TAssertions>(this FluentAssertionsAsync.Primitives.ReferenceTypeAssertions<TSubject, TAssertions> _)
            where TAssertions : FluentAssertionsAsync.Primitives.ReferenceTypeAssertions<TSubject, TAssertions> { }
        public static FluentAssertionsAsync.Collections.GenericDictionaryAssertions<System.Collections.Generic.IDictionary<TKey, TValue>, TKey, TValue> Should<TKey, TValue>(this System.Collections.Generic.IDictionary<TKey, TValue> actualValue) { }
        public static FluentAssertionsAsync.Collections.GenericDictionaryAssertions<System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, TKey, TValue> Should<TKey, TValue>(this System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> actualValue) { }
        public static FluentAssertionsAsync.Collections.GenericDictionaryAssertions<TCollection, TKey, TValue> Should<TCollection, TKey, TValue>(this TCollection actualValue)
            where TCollection : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> { }
    }
    public static class AssertionOptions
    {
        public static FluentAssertionsAsync.EquivalencyPlan EquivalencyPlan { get; }
        public static FluentAssertionsAsync.Formatting.FormattingOptions FormattingOptions { get; }
        public static void AssertEquivalencyUsing(System.Func<FluentAssertionsAsync.Equivalency.EquivalencyOptions, FluentAssertionsAsync.Equivalency.EquivalencyOptions> defaultsConfigurer) { }
        public static FluentAssertionsAsync.Equivalency.EquivalencyOptions<T> CloneDefaults<T>() { }
    }
    public static class AsyncAssertionsExtensions
    {
        public static System.Threading.Tasks.Task<FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Specialized.GenericAsyncFunctionAssertions<T>, T>> WithResult<T>(this System.Threading.Tasks.Task<FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Specialized.GenericAsyncFunctionAssertions<T>, T>> task, T expected, string because = "", params object[] becauseArgs) { }
        public static System.Threading.Tasks.Task<FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Specialized.TaskCompletionSourceAssertions<T>, T>> WithResult<T>(this System.Threading.Tasks.Task<FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Specialized.TaskCompletionSourceAssertions<T>, T>> task, T expected, string because = "", params object[] becauseArgs) { }
    }
    public static class AtLeast
    {
        public static FluentAssertionsAsync.OccurrenceConstraint Once() { }
        public static FluentAssertionsAsync.OccurrenceConstraint Thrice() { }
        public static FluentAssertionsAsync.OccurrenceConstraint Times(int expected) { }
        public static FluentAssertionsAsync.OccurrenceConstraint Twice() { }
    }
    public static class AtMost
    {
        public static FluentAssertionsAsync.OccurrenceConstraint Once() { }
        public static FluentAssertionsAsync.OccurrenceConstraint Thrice() { }
        public static FluentAssertionsAsync.OccurrenceConstraint Times(int expected) { }
        public static FluentAssertionsAsync.OccurrenceConstraint Twice() { }
    }
    public static class CallerIdentifier
    {
        public static System.Action<string> Logger { get; set; }
        public static string DetermineCallerIdentity() { }
    }
    [System.AttributeUsage(System.AttributeTargets.Method)]
    public class CustomAssertionAttribute : System.Attribute
    {
        public CustomAssertionAttribute() { }
    }
    [System.AttributeUsage(System.AttributeTargets.Assembly)]
    public sealed class CustomAssertionsAssemblyAttribute : System.Attribute
    {
        public CustomAssertionsAssemblyAttribute() { }
    }
    public static class EnumAssertionsExtensions
    {
        public static FluentAssertionsAsync.Primitives.EnumAssertions<TEnum> Should<TEnum>(this TEnum @enum)
            where TEnum :  struct, System.Enum { }
        public static FluentAssertionsAsync.Primitives.NullableEnumAssertions<TEnum> Should<TEnum>(this TEnum? @enum)
            where TEnum :  struct, System.Enum { }
    }
    public class EquivalencyPlan : System.Collections.Generic.IEnumerable<FluentAssertionsAsync.Equivalency.IEquivalencyStep>, System.Collections.IEnumerable
    {
        public EquivalencyPlan() { }
        public void Add<TStep>()
            where TStep : FluentAssertionsAsync.Equivalency.IEquivalencyStep, new () { }
        public void AddAfter<TPredecessor, TStep>()
            where TStep : FluentAssertionsAsync.Equivalency.IEquivalencyStep, new () { }
        public void Clear() { }
        public System.Collections.Generic.IEnumerator<FluentAssertionsAsync.Equivalency.IEquivalencyStep> GetEnumerator() { }
        public void Insert<TStep>()
            where TStep : FluentAssertionsAsync.Equivalency.IEquivalencyStep, new () { }
        public void InsertBefore<TSuccessor, TStep>()
            where TStep : FluentAssertionsAsync.Equivalency.IEquivalencyStep, new () { }
        public void Remove<TStep>()
            where TStep : FluentAssertionsAsync.Equivalency.IEquivalencyStep { }
        public void Reset() { }
    }
    public static class Exactly
    {
        public static FluentAssertionsAsync.OccurrenceConstraint Once() { }
        public static FluentAssertionsAsync.OccurrenceConstraint Thrice() { }
        public static FluentAssertionsAsync.OccurrenceConstraint Times(int expected) { }
        public static FluentAssertionsAsync.OccurrenceConstraint Twice() { }
    }
    public static class ExceptionAssertionsExtensions
    {
        public static System.Threading.Tasks.Task<FluentAssertionsAsync.Specialized.ExceptionAssertions<TException>> Where<TException>(this System.Threading.Tasks.Task<FluentAssertionsAsync.Specialized.ExceptionAssertions<TException>> task, System.Linq.Expressions.Expression<System.Func<TException, bool>> exceptionExpression, string because = "", params object[] becauseArgs)
            where TException : System.Exception { }
        public static System.Threading.Tasks.Task<FluentAssertionsAsync.Specialized.ExceptionAssertions<System.Exception>> WithInnerException<TException>(this System.Threading.Tasks.Task<FluentAssertionsAsync.Specialized.ExceptionAssertions<TException>> task, System.Type innerException, string because = "", params object[] becauseArgs)
            where TException : System.Exception { }
        public static System.Threading.Tasks.Task<FluentAssertionsAsync.Specialized.ExceptionAssertions<TInnerException>> WithInnerException<TException, TInnerException>(this System.Threading.Tasks.Task<FluentAssertionsAsync.Specialized.ExceptionAssertions<TException>> task, string because = "", params object[] becauseArgs)
            where TException : System.Exception
            where TInnerException : System.Exception { }
        public static System.Threading.Tasks.Task<FluentAssertionsAsync.Specialized.ExceptionAssertions<System.Exception>> WithInnerExceptionExactly<TException>(this System.Threading.Tasks.Task<FluentAssertionsAsync.Specialized.ExceptionAssertions<TException>> task, System.Type innerException, string because = "", params object[] becauseArgs)
            where TException : System.Exception { }
        public static System.Threading.Tasks.Task<FluentAssertionsAsync.Specialized.ExceptionAssertions<TInnerException>> WithInnerExceptionExactly<TException, TInnerException>(this System.Threading.Tasks.Task<FluentAssertionsAsync.Specialized.ExceptionAssertions<TException>> task, string because = "", params object[] becauseArgs)
            where TException : System.Exception
            where TInnerException : System.Exception { }
        public static System.Threading.Tasks.Task<FluentAssertionsAsync.Specialized.ExceptionAssertions<TException>> WithMessage<TException>(this System.Threading.Tasks.Task<FluentAssertionsAsync.Specialized.ExceptionAssertions<TException>> task, string expectedWildcardPattern, string because = "", params object[] becauseArgs)
            where TException : System.Exception { }
        public static FluentAssertionsAsync.Specialized.ExceptionAssertions<TException> WithParameterName<TException>(this FluentAssertionsAsync.Specialized.ExceptionAssertions<TException> parent, string paramName, string because = "", params object[] becauseArgs)
            where TException : System.ArgumentException { }
        public static System.Threading.Tasks.Task<FluentAssertionsAsync.Specialized.ExceptionAssertions<TException>> WithParameterName<TException>(this System.Threading.Tasks.Task<FluentAssertionsAsync.Specialized.ExceptionAssertions<TException>> task, string paramName, string because = "", params object[] becauseArgs)
            where TException : System.ArgumentException { }
    }
    public static class FluentActions
    {
        public static System.Func<System.Threading.Tasks.Task> Awaiting(System.Func<System.Threading.Tasks.Task> action) { }
        public static System.Func<System.Threading.Tasks.Task<T>> Awaiting<T>(System.Func<System.Threading.Tasks.Task<T>> func) { }
        public static System.Action Enumerating(System.Func<System.Collections.IEnumerable> enumerable) { }
        public static System.Action Enumerating<T>(System.Func<System.Collections.Generic.IEnumerable<T>> enumerable) { }
        public static System.Action Invoking(System.Action action) { }
        public static System.Func<T> Invoking<T>(System.Func<T> func) { }
    }
    public static class LessThan
    {
        public static FluentAssertionsAsync.OccurrenceConstraint Thrice() { }
        public static FluentAssertionsAsync.OccurrenceConstraint Times(int expected) { }
        public static FluentAssertionsAsync.OccurrenceConstraint Twice() { }
    }
    public static class MoreThan
    {
        public static FluentAssertionsAsync.OccurrenceConstraint Once() { }
        public static FluentAssertionsAsync.OccurrenceConstraint Thrice() { }
        public static FluentAssertionsAsync.OccurrenceConstraint Times(int expected) { }
        public static FluentAssertionsAsync.OccurrenceConstraint Twice() { }
    }
    public static class NumericAssertionsExtensions
    {
        public static FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Numeric.NullableNumericAssertions<decimal>> BeApproximately(this FluentAssertionsAsync.Numeric.NullableNumericAssertions<decimal> parent, decimal expectedValue, decimal precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Numeric.NullableNumericAssertions<decimal>> BeApproximately(this FluentAssertionsAsync.Numeric.NullableNumericAssertions<decimal> parent, decimal? expectedValue, decimal precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Numeric.NullableNumericAssertions<double>> BeApproximately(this FluentAssertionsAsync.Numeric.NullableNumericAssertions<double> parent, double expectedValue, double precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Numeric.NullableNumericAssertions<double>> BeApproximately(this FluentAssertionsAsync.Numeric.NullableNumericAssertions<double> parent, double? expectedValue, double precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Numeric.NullableNumericAssertions<float>> BeApproximately(this FluentAssertionsAsync.Numeric.NullableNumericAssertions<float> parent, float expectedValue, float precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Numeric.NullableNumericAssertions<float>> BeApproximately(this FluentAssertionsAsync.Numeric.NullableNumericAssertions<float> parent, float? expectedValue, float precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Numeric.NumericAssertions<decimal>> BeApproximately(this FluentAssertionsAsync.Numeric.NumericAssertions<decimal> parent, decimal expectedValue, decimal precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Numeric.NumericAssertions<double>> BeApproximately(this FluentAssertionsAsync.Numeric.NumericAssertions<double> parent, double expectedValue, double precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Numeric.NumericAssertions<float>> BeApproximately(this FluentAssertionsAsync.Numeric.NumericAssertions<float> parent, float expectedValue, float precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Numeric.NumericAssertions<byte>> BeCloseTo(this FluentAssertionsAsync.Numeric.NumericAssertions<byte> parent, byte nearbyValue, byte delta, string because = "", params object[] becauseArgs) { }
        public static FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Numeric.NumericAssertions<short>> BeCloseTo(this FluentAssertionsAsync.Numeric.NumericAssertions<short> parent, short nearbyValue, ushort delta, string because = "", params object[] becauseArgs) { }
        public static FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Numeric.NumericAssertions<int>> BeCloseTo(this FluentAssertionsAsync.Numeric.NumericAssertions<int> parent, int nearbyValue, uint delta, string because = "", params object[] becauseArgs) { }
        public static FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Numeric.NumericAssertions<long>> BeCloseTo(this FluentAssertionsAsync.Numeric.NumericAssertions<long> parent, long nearbyValue, ulong delta, string because = "", params object[] becauseArgs) { }
        public static FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Numeric.NumericAssertions<sbyte>> BeCloseTo(this FluentAssertionsAsync.Numeric.NumericAssertions<sbyte> parent, sbyte nearbyValue, byte delta, string because = "", params object[] becauseArgs) { }
        public static FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Numeric.NumericAssertions<ushort>> BeCloseTo(this FluentAssertionsAsync.Numeric.NumericAssertions<ushort> parent, ushort nearbyValue, ushort delta, string because = "", params object[] becauseArgs) { }
        public static FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Numeric.NumericAssertions<uint>> BeCloseTo(this FluentAssertionsAsync.Numeric.NumericAssertions<uint> parent, uint nearbyValue, uint delta, string because = "", params object[] becauseArgs) { }
        public static FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Numeric.NumericAssertions<ulong>> BeCloseTo(this FluentAssertionsAsync.Numeric.NumericAssertions<ulong> parent, ulong nearbyValue, ulong delta, string because = "", params object[] becauseArgs) { }
        public static FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Numeric.NullableNumericAssertions<decimal>> NotBeApproximately(this FluentAssertionsAsync.Numeric.NullableNumericAssertions<decimal> parent, decimal unexpectedValue, decimal precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Numeric.NullableNumericAssertions<decimal>> NotBeApproximately(this FluentAssertionsAsync.Numeric.NullableNumericAssertions<decimal> parent, decimal? unexpectedValue, decimal precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Numeric.NullableNumericAssertions<double>> NotBeApproximately(this FluentAssertionsAsync.Numeric.NullableNumericAssertions<double> parent, double unexpectedValue, double precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Numeric.NullableNumericAssertions<double>> NotBeApproximately(this FluentAssertionsAsync.Numeric.NullableNumericAssertions<double> parent, double? unexpectedValue, double precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Numeric.NullableNumericAssertions<float>> NotBeApproximately(this FluentAssertionsAsync.Numeric.NullableNumericAssertions<float> parent, float unexpectedValue, float precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Numeric.NullableNumericAssertions<float>> NotBeApproximately(this FluentAssertionsAsync.Numeric.NullableNumericAssertions<float> parent, float? unexpectedValue, float precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Numeric.NumericAssertions<decimal>> NotBeApproximately(this FluentAssertionsAsync.Numeric.NumericAssertions<decimal> parent, decimal unexpectedValue, decimal precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Numeric.NumericAssertions<double>> NotBeApproximately(this FluentAssertionsAsync.Numeric.NumericAssertions<double> parent, double unexpectedValue, double precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Numeric.NumericAssertions<float>> NotBeApproximately(this FluentAssertionsAsync.Numeric.NumericAssertions<float> parent, float unexpectedValue, float precision, string because = "", params object[] becauseArgs) { }
        public static FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Numeric.NumericAssertions<byte>> NotBeCloseTo(this FluentAssertionsAsync.Numeric.NumericAssertions<byte> parent, byte distantValue, byte delta, string because = "", params object[] becauseArgs) { }
        public static FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Numeric.NumericAssertions<short>> NotBeCloseTo(this FluentAssertionsAsync.Numeric.NumericAssertions<short> parent, short distantValue, ushort delta, string because = "", params object[] becauseArgs) { }
        public static FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Numeric.NumericAssertions<int>> NotBeCloseTo(this FluentAssertionsAsync.Numeric.NumericAssertions<int> parent, int distantValue, uint delta, string because = "", params object[] becauseArgs) { }
        public static FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Numeric.NumericAssertions<long>> NotBeCloseTo(this FluentAssertionsAsync.Numeric.NumericAssertions<long> parent, long distantValue, ulong delta, string because = "", params object[] becauseArgs) { }
        public static FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Numeric.NumericAssertions<sbyte>> NotBeCloseTo(this FluentAssertionsAsync.Numeric.NumericAssertions<sbyte> parent, sbyte distantValue, byte delta, string because = "", params object[] becauseArgs) { }
        public static FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Numeric.NumericAssertions<ushort>> NotBeCloseTo(this FluentAssertionsAsync.Numeric.NumericAssertions<ushort> parent, ushort distantValue, ushort delta, string because = "", params object[] becauseArgs) { }
        public static FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Numeric.NumericAssertions<uint>> NotBeCloseTo(this FluentAssertionsAsync.Numeric.NumericAssertions<uint> parent, uint distantValue, uint delta, string because = "", params object[] becauseArgs) { }
        public static FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Numeric.NumericAssertions<ulong>> NotBeCloseTo(this FluentAssertionsAsync.Numeric.NumericAssertions<ulong> parent, ulong distantValue, ulong delta, string because = "", params object[] becauseArgs) { }
    }
    public static class ObjectAssertionsExtensions
    {
        public static System.Threading.Tasks.Task<FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Primitives.ObjectAssertions>> BeDataContractSerializableAsync(this FluentAssertionsAsync.Primitives.ObjectAssertions assertions, string because = "", params object[] becauseArgs) { }
        public static System.Threading.Tasks.Task<FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Primitives.ObjectAssertions>> BeDataContractSerializableAsync<T>(this FluentAssertionsAsync.Primitives.ObjectAssertions assertions, System.Func<FluentAssertionsAsync.Equivalency.EquivalencyOptions<T>, FluentAssertionsAsync.Equivalency.EquivalencyOptions<T>> options, string because = "", params object[] becauseArgs) { }
        public static System.Threading.Tasks.Task<FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Primitives.ObjectAssertions>> BeXmlSerializableAsync(this FluentAssertionsAsync.Primitives.ObjectAssertions assertions, string because = "", params object[] becauseArgs) { }
    }
    public abstract class OccurrenceConstraint
    {
        protected OccurrenceConstraint(int expectedCount) { }
    }
    public static class TypeEnumerableExtensions
    {
        public static System.Collections.Generic.IEnumerable<System.Type> ThatAreClasses(this System.Collections.Generic.IEnumerable<System.Type> types) { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatAreDecoratedWith<TAttribute>(this System.Collections.Generic.IEnumerable<System.Type> types)
            where TAttribute : System.Attribute { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatAreDecoratedWithOrInherit<TAttribute>(this System.Collections.Generic.IEnumerable<System.Type> types)
            where TAttribute : System.Attribute { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatAreInNamespace(this System.Collections.Generic.IEnumerable<System.Type> types, string @namespace) { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatAreNotClasses(this System.Collections.Generic.IEnumerable<System.Type> types) { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatAreNotDecoratedWith<TAttribute>(this System.Collections.Generic.IEnumerable<System.Type> types)
            where TAttribute : System.Attribute { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatAreNotDecoratedWithOrInherit<TAttribute>(this System.Collections.Generic.IEnumerable<System.Type> types)
            where TAttribute : System.Attribute { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatAreNotStatic(this System.Collections.Generic.IEnumerable<System.Type> types) { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatAreStatic(this System.Collections.Generic.IEnumerable<System.Type> types) { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatAreUnderNamespace(this System.Collections.Generic.IEnumerable<System.Type> types, string @namespace) { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatDeriveFrom<T>(this System.Collections.Generic.IEnumerable<System.Type> types) { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatImplement<T>(this System.Collections.Generic.IEnumerable<System.Type> types) { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatSatisfy(this System.Collections.Generic.IEnumerable<System.Type> types, System.Func<System.Type, bool> predicate) { }
        public static System.Collections.Generic.IEnumerable<System.Type> UnwrapEnumerableTypes(this System.Collections.Generic.IEnumerable<System.Type> types) { }
        public static System.Collections.Generic.IEnumerable<System.Type> UnwrapTaskTypes(this System.Collections.Generic.IEnumerable<System.Type> types) { }
    }
    public static class TypeExtensions
    {
        public static FluentAssertionsAsync.Types.MethodInfoSelector Methods(this FluentAssertionsAsync.Types.TypeSelector typeSelector) { }
        public static FluentAssertionsAsync.Types.MethodInfoSelector Methods(this System.Type type) { }
        public static FluentAssertionsAsync.Types.PropertyInfoSelector Properties(this FluentAssertionsAsync.Types.TypeSelector typeSelector) { }
        public static FluentAssertionsAsync.Types.PropertyInfoSelector Properties(this System.Type type) { }
        public static FluentAssertionsAsync.Types.TypeSelector Types(this System.Collections.Generic.IEnumerable<System.Type> types) { }
        public static FluentAssertionsAsync.Types.TypeSelector Types(this System.Reflection.Assembly assembly) { }
        public static FluentAssertionsAsync.Types.TypeSelector Types(this System.Type type) { }
    }
    public static class XmlAssertionExtensions
    {
        public static FluentAssertionsAsync.Xml.XmlElementAssertions Should(this System.Xml.XmlElement actualValue) { }
        public static FluentAssertionsAsync.Xml.XmlNodeAssertions Should(this System.Xml.XmlNode actualValue) { }
    }
}
namespace FluentAssertionsAsync.Collections
{
    public class GenericCollectionAssertions<T> : FluentAssertionsAsync.Collections.GenericCollectionAssertions<System.Collections.Generic.IEnumerable<T>, T, FluentAssertionsAsync.Collections.GenericCollectionAssertions<T>>
    {
        public GenericCollectionAssertions(System.Collections.Generic.IEnumerable<T> actualValue) { }
    }
    public class GenericCollectionAssertions<TCollection, T> : FluentAssertionsAsync.Collections.GenericCollectionAssertions<TCollection, T, FluentAssertionsAsync.Collections.GenericCollectionAssertions<TCollection, T>>
        where TCollection : System.Collections.Generic.IEnumerable<T>
    {
        public GenericCollectionAssertions(TCollection actualValue) { }
    }
    public class GenericCollectionAssertions<TCollection, T, TAssertions> : FluentAssertionsAsync.Primitives.ReferenceTypeAssertions<TCollection, TAssertions>
        where TCollection : System.Collections.Generic.IEnumerable<T>
        where TAssertions : FluentAssertionsAsync.Collections.GenericCollectionAssertions<TCollection, T, TAssertions>
    {
        public GenericCollectionAssertions(TCollection actualValue) { }
        protected override string Identifier { get; }
        public FluentAssertionsAsync.AndConstraint<TAssertions> AllBeAssignableTo(System.Type expectedType, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<TAssertions, System.Collections.Generic.IEnumerable<TExpectation>> AllBeAssignableTo<TExpectation>(string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndConstraint<TAssertions>> AllBeEquivalentToAsync<TExpectation>(TExpectation expectation, string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndConstraint<TAssertions>> AllBeEquivalentToAsync<TExpectation>(TExpectation expectation, System.Func<FluentAssertionsAsync.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertionsAsync.Equivalency.EquivalencyOptions<TExpectation>> config, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> AllBeOfType(System.Type expectedType, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<TAssertions, System.Collections.Generic.IEnumerable<TExpectation>> AllBeOfType<TExpectation>(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> AllSatisfy(System.Action<T> expected, string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndConstraint<TAssertions>> AllSatisfyAsync(System.Func<T, System.Threading.Tasks.Task> expected, string because = "", params object[] becauseArgs) { }
        protected void AssertCollectionEndsWith<TActual, TExpectation>(System.Collections.Generic.IEnumerable<TActual> actual, System.Collections.Generic.ICollection<TExpectation> expected, System.Func<TActual, TExpectation, bool> equalityComparison, string because = "", params object[] becauseArgs) { }
        protected void AssertCollectionStartsWith<TActual, TExpectation>(System.Collections.Generic.IEnumerable<TActual> actualItems, System.Collections.Generic.ICollection<TExpectation> expected, System.Func<TActual, TExpectation, bool> equalityComparison, string because = "", params object[] becauseArgs) { }
        protected void AssertSubjectEquality<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, System.Func<T, TExpectation, bool> equalityComparison, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeEmpty(string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndConstraint<TAssertions>> BeEquivalentToAsync<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndConstraint<TAssertions>> BeEquivalentToAsync<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, System.Func<FluentAssertionsAsync.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertionsAsync.Equivalency.EquivalencyOptions<TExpectation>> config, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Collections.SubsequentOrderingAssertions<T>> BeInAscendingOrder(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Collections.SubsequentOrderingAssertions<T>> BeInAscendingOrder(System.Collections.Generic.IComparer<T> comparer, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Collections.SubsequentOrderingAssertions<T>> BeInAscendingOrder(System.Func<T, T, int> comparison, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Collections.SubsequentOrderingAssertions<T>> BeInAscendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Collections.SubsequentOrderingAssertions<T>> BeInAscendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, System.Collections.Generic.IComparer<TSelector> comparer, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Collections.SubsequentOrderingAssertions<T>> BeInDescendingOrder(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Collections.SubsequentOrderingAssertions<T>> BeInDescendingOrder(System.Collections.Generic.IComparer<T> comparer, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Collections.SubsequentOrderingAssertions<T>> BeInDescendingOrder(System.Func<T, T, int> comparison, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Collections.SubsequentOrderingAssertions<T>> BeInDescendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Collections.SubsequentOrderingAssertions<T>> BeInDescendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, System.Collections.Generic.IComparer<TSelector> comparer, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeNullOrEmpty(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeSubsetOf(System.Collections.Generic.IEnumerable<T> expectedSuperset, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Contain(System.Collections.Generic.IEnumerable<T> expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<TAssertions, T> Contain(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<TAssertions, T> Contain(T expected, string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndWhichConstraint<TAssertions, T>> ContainEquivalentOfAsync<TExpectation>(TExpectation expectation, string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndWhichConstraint<TAssertions, T>> ContainEquivalentOfAsync<TExpectation>(TExpectation expectation, System.Func<FluentAssertionsAsync.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertionsAsync.Equivalency.EquivalencyOptions<TExpectation>> config, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> ContainInConsecutiveOrder(params T[] expected) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> ContainInConsecutiveOrder(System.Collections.Generic.IEnumerable<T> expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> ContainInOrder(params T[] expected) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> ContainInOrder(System.Collections.Generic.IEnumerable<T> expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> ContainItemsAssignableTo<TExpectation>(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<TAssertions, T> ContainSingle(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<TAssertions, T> ContainSingle(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> EndWith(System.Collections.Generic.IEnumerable<T> expectation, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> EndWith(T element, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> EndWith<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, System.Func<T, TExpectation, bool> equalityComparison, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Equal(params T[] elements) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Equal(System.Collections.Generic.IEnumerable<T> expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Equal<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, System.Func<T, TExpectation, bool> equalityComparison, string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveCount(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveCount(System.Linq.Expressions.Expression<System.Func<int, bool>> countPredicate, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveCountGreaterThan(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveCountGreaterThanOrEqualTo(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveCountLessThan(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveCountLessThanOrEqualTo(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<TAssertions, T> HaveElementAt(int index, T element, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveElementPreceding(T successor, T expectation, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveElementSucceeding(T predecessor, T expectation, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveSameCount<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> otherCollection, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> IntersectWith(System.Collections.Generic.IEnumerable<T> otherCollection, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeEmpty(string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndConstraint<TAssertions>> NotBeEquivalentToAsync<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> unexpected, string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndConstraint<TAssertions>> NotBeEquivalentToAsync<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> unexpected, System.Func<FluentAssertionsAsync.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertionsAsync.Equivalency.EquivalencyOptions<TExpectation>> config, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeInAscendingOrder(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeInAscendingOrder(System.Collections.Generic.IComparer<T> comparer, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeInAscendingOrder(System.Func<T, T, int> comparison, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeInAscendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeInAscendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, System.Collections.Generic.IComparer<TSelector> comparer, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeInDescendingOrder(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeInDescendingOrder(System.Collections.Generic.IComparer<T> comparer, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeInDescendingOrder(System.Func<T, T, int> comparison, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeInDescendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeInDescendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, System.Collections.Generic.IComparer<TSelector> comparer, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeNullOrEmpty(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeSubsetOf(System.Collections.Generic.IEnumerable<T> unexpectedSuperset, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotContain(System.Collections.Generic.IEnumerable<T> unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotContain(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<TAssertions, T> NotContain(T unexpected, string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndConstraint<TAssertions>> NotContainEquivalentOfAsync<TExpectation>(TExpectation unexpected, string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndConstraint<TAssertions>> NotContainEquivalentOfAsync<TExpectation>(TExpectation unexpected, System.Func<FluentAssertionsAsync.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertionsAsync.Equivalency.EquivalencyOptions<TExpectation>> config, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotContainInConsecutiveOrder(params T[] unexpected) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotContainInConsecutiveOrder(System.Collections.Generic.IEnumerable<T> unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotContainInOrder(params T[] unexpected) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotContainInOrder(System.Collections.Generic.IEnumerable<T> unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotContainItemsAssignableTo(System.Type type, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotContainItemsAssignableTo<TExpectation>(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotContainNulls(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotContainNulls<TKey>(System.Linq.Expressions.Expression<System.Func<T, TKey>> predicate, string because = "", params object[] becauseArgs)
            where TKey :  class { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotEqual(System.Collections.Generic.IEnumerable<T> unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotHaveCount(int unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotHaveSameCount<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> otherCollection, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotIntersectWith(System.Collections.Generic.IEnumerable<T> otherCollection, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> OnlyContain(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> OnlyHaveUniqueItems(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> OnlyHaveUniqueItems<TKey>(System.Linq.Expressions.Expression<System.Func<T, TKey>> predicate, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Satisfy(params System.Linq.Expressions.Expression<System.Func<T, bool>>[] predicates) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Satisfy(System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression<System.Func<T, bool>>> predicates, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> SatisfyRespectively(params System.Action<T>[] elementInspectors) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> SatisfyRespectively(System.Collections.Generic.IEnumerable<System.Action<T>> expected, string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndConstraint<TAssertions>> SatisfyRespectivelyAsync(params System.Func<T, System.Threading.Tasks.Task>[] elementInspectors) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndConstraint<TAssertions>> SatisfyRespectivelyAsync(System.Collections.Generic.IEnumerable<System.Func<T, System.Threading.Tasks.Task>> expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> StartWith(System.Collections.Generic.IEnumerable<T> expectation, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> StartWith(T element, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> StartWith<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, System.Func<T, TExpectation, bool> equalityComparison, string because = "", params object[] becauseArgs) { }
        protected static System.Collections.Generic.IEnumerable<TExpectation> RepeatAsManyAs<TExpectation>(TExpectation value, System.Collections.Generic.IEnumerable<T> enumerable) { }
    }
    public class GenericDictionaryAssertions<TCollection, TKey, TValue> : FluentAssertionsAsync.Collections.GenericDictionaryAssertions<TCollection, TKey, TValue, FluentAssertionsAsync.Collections.GenericDictionaryAssertions<TCollection, TKey, TValue>>
        where TCollection : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>
    {
        public GenericDictionaryAssertions(TCollection keyValuePairs) { }
    }
    public class GenericDictionaryAssertions<TCollection, TKey, TValue, TAssertions> : FluentAssertionsAsync.Collections.GenericCollectionAssertions<TCollection, System.Collections.Generic.KeyValuePair<TKey, TValue>, TAssertions>
        where TCollection : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>
        where TAssertions : FluentAssertionsAsync.Collections.GenericDictionaryAssertions<TCollection, TKey, TValue, TAssertions>
    {
        public GenericDictionaryAssertions(TCollection keyValuePairs) { }
        protected override string Identifier { get; }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndConstraint<TAssertions>> BeEquivalentToAsync<TExpectation>(TExpectation expectation, string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndConstraint<TAssertions>> BeEquivalentToAsync<TExpectation>(TExpectation expectation, System.Func<FluentAssertionsAsync.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertionsAsync.Equivalency.EquivalencyOptions<TExpectation>> config, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Contain(params System.Collections.Generic.KeyValuePair<TKey, TValue>[] expected) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Contain(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Contain(System.Collections.Generic.KeyValuePair<TKey, TValue> expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Contain(TKey key, TValue value, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.Collections.WhoseValueConstraint<TCollection, TKey, TValue, TAssertions> ContainKey(TKey expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> ContainKeys(params TKey[] expected) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> ContainKeys(System.Collections.Generic.IEnumerable<TKey> expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<TAssertions, TValue> ContainValue(TValue expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> ContainValues(params TValue[] expected) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> ContainValues(System.Collections.Generic.IEnumerable<TValue> expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Equal<T>(T expected, string because = "", params object[] becauseArgs)
            where T : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotContain(params System.Collections.Generic.KeyValuePair<TKey, TValue>[] items) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotContain(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> items, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotContain(System.Collections.Generic.KeyValuePair<TKey, TValue> item, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotContain(TKey key, TValue value, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotContainKey(TKey unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotContainKeys(params TKey[] unexpected) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotContainKeys(System.Collections.Generic.IEnumerable<TKey> unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotContainValue(TValue unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotContainValues(params TValue[] unexpected) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotContainValues(System.Collections.Generic.IEnumerable<TValue> unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotEqual<T>(T unexpected, string because = "", params object[] becauseArgs)
            where T : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> { }
    }
    public class StringCollectionAssertions : FluentAssertionsAsync.Collections.StringCollectionAssertions<System.Collections.Generic.IEnumerable<string>>
    {
        public StringCollectionAssertions(System.Collections.Generic.IEnumerable<string> actualValue) { }
    }
    public class StringCollectionAssertions<TCollection> : FluentAssertionsAsync.Collections.StringCollectionAssertions<TCollection, FluentAssertionsAsync.Collections.StringCollectionAssertions<TCollection>>
        where TCollection : System.Collections.Generic.IEnumerable<string>
    {
        public StringCollectionAssertions(TCollection actualValue) { }
    }
    public class StringCollectionAssertions<TCollection, TAssertions> : FluentAssertionsAsync.Collections.GenericCollectionAssertions<TCollection, string, TAssertions>
        where TCollection : System.Collections.Generic.IEnumerable<string>
        where TAssertions : FluentAssertionsAsync.Collections.StringCollectionAssertions<TCollection, TAssertions>
    {
        public StringCollectionAssertions(TCollection actualValue) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndConstraint<TAssertions>> AllBeAsync(string expectation, string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndConstraint<TAssertions>> AllBeAsync(string expectation, System.Func<FluentAssertionsAsync.Equivalency.EquivalencyOptions<string>, FluentAssertionsAsync.Equivalency.EquivalencyOptions<string>> config, string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndConstraint<TAssertions>> BeEquivalentToAsync(params string[] expectation) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndConstraint<TAssertions>> BeEquivalentToAsync(System.Collections.Generic.IEnumerable<string> expectation, string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndConstraint<TAssertions>> BeEquivalentToAsync(System.Collections.Generic.IEnumerable<string> expectation, System.Func<FluentAssertionsAsync.Equivalency.EquivalencyOptions<string>, FluentAssertionsAsync.Equivalency.EquivalencyOptions<string>> config, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<TAssertions, string> ContainMatch(string wildcardPattern, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Equal(System.Collections.Generic.IEnumerable<string> expected) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Equal(params string[] expected) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotContainMatch(string wildcardPattern, string because = "", params object[] becauseArgs) { }
    }
    public class SubsequentOrderingAssertions<T> : FluentAssertionsAsync.Collections.SubsequentOrderingGenericCollectionAssertions<System.Collections.Generic.IEnumerable<T>, T, FluentAssertionsAsync.Collections.SubsequentOrderingAssertions<T>>
    {
        public SubsequentOrderingAssertions(System.Collections.Generic.IEnumerable<T> actualValue, System.Linq.IOrderedEnumerable<T> previousOrderedEnumerable) { }
    }
    public class SubsequentOrderingGenericCollectionAssertions<TCollection, T> : FluentAssertionsAsync.Collections.SubsequentOrderingGenericCollectionAssertions<TCollection, T, FluentAssertionsAsync.Collections.SubsequentOrderingGenericCollectionAssertions<TCollection, T>>
        where TCollection : System.Collections.Generic.IEnumerable<T>
    {
        public SubsequentOrderingGenericCollectionAssertions(TCollection actualValue, System.Linq.IOrderedEnumerable<T> previousOrderedEnumerable) { }
    }
    public class SubsequentOrderingGenericCollectionAssertions<TCollection, T, TAssertions> : FluentAssertionsAsync.Collections.GenericCollectionAssertions<TCollection, T, TAssertions>
        where TCollection : System.Collections.Generic.IEnumerable<T>
        where TAssertions : FluentAssertionsAsync.Collections.SubsequentOrderingGenericCollectionAssertions<TCollection, T, TAssertions>
    {
        public SubsequentOrderingGenericCollectionAssertions(TCollection actualValue, System.Linq.IOrderedEnumerable<T> previousOrderedEnumerable) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Collections.SubsequentOrderingAssertions<T>> ThenBeInAscendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Collections.SubsequentOrderingAssertions<T>> ThenBeInAscendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, System.Collections.Generic.IComparer<TSelector> comparer, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Collections.SubsequentOrderingAssertions<T>> ThenBeInDescendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Collections.SubsequentOrderingAssertions<T>> ThenBeInDescendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, System.Collections.Generic.IComparer<TSelector> comparer, string because = "", params object[] becauseArgs) { }
    }
    public class WhoseValueConstraint<TCollection, TKey, TValue, TAssertions> : FluentAssertionsAsync.AndConstraint<TAssertions>
        where TCollection : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>
        where TAssertions : FluentAssertionsAsync.Collections.GenericDictionaryAssertions<TCollection, TKey, TValue, TAssertions>
    {
        public WhoseValueConstraint(TAssertions parentConstraint, TValue value) { }
        public TValue WhoseValue { get; }
    }
}
namespace FluentAssertionsAsync.Common
{
    public enum CSharpAccessModifier
    {
        Public = 0,
        Private = 1,
        Protected = 2,
        Internal = 3,
        ProtectedInternal = 4,
        InvalidForCSharp = 5,
        PrivateProtected = 6,
    }
    public class Configuration
    {
        public Configuration(FluentAssertionsAsync.Common.IConfigurationStore store) { }
        public string TestFrameworkName { get; set; }
        public string ValueFormatterAssembly { get; set; }
        public FluentAssertionsAsync.Common.ValueFormatterDetectionMode ValueFormatterDetectionMode { get; set; }
        public static FluentAssertionsAsync.Common.Configuration Current { get; }
    }
    public static class DateTimeExtensions
    {
        public static System.DateTimeOffset ToDateTimeOffset(this System.DateTime dateTime) { }
        public static System.DateTimeOffset ToDateTimeOffset(this System.DateTime dateTime, System.TimeSpan offset) { }
    }
    public interface IClock
    {
        void Delay(System.TimeSpan timeToDelay);
        System.Threading.Tasks.Task DelayAsync(System.TimeSpan delay, System.Threading.CancellationToken cancellationToken);
        FluentAssertionsAsync.Common.ITimer StartTimer();
    }
    public interface IConfigurationStore
    {
        string GetSetting(string name);
    }
    public interface IReflector
    {
        System.Collections.Generic.IEnumerable<System.Type> GetAllTypesFromAppDomain(System.Func<System.Reflection.Assembly, bool> predicate);
    }
    public interface ITimer : System.IDisposable
    {
        System.TimeSpan Elapsed { get; }
    }
    public static class Services
    {
        public static FluentAssertionsAsync.Common.Configuration Configuration { get; }
        public static FluentAssertionsAsync.Common.IConfigurationStore ConfigurationStore { get; set; }
        public static FluentAssertionsAsync.Common.IReflector Reflector { get; set; }
        public static System.Action<string> ThrowException { get; set; }
        public static void ResetToDefaults() { }
    }
    public delegate FluentAssertionsAsync.Common.ITimer StartTimer();
    public enum ValueFormatterDetectionMode
    {
        Disabled = 0,
        Specific = 1,
        Scan = 2,
    }
}
namespace FluentAssertionsAsync.Equivalency
{
    public class Comparands
    {
        public Comparands() { }
        public Comparands(object subject, object expectation, System.Type compileTimeType) { }
        public System.Type CompileTimeType { get; set; }
        public object Expectation { get; set; }
        public System.Type RuntimeType { get; }
        public object Subject { get; set; }
        public System.Type GetExpectedType(FluentAssertionsAsync.Equivalency.IEquivalencyOptions options) { }
        public override string ToString() { }
    }
    public class ConversionSelector
    {
        public ConversionSelector() { }
        public FluentAssertionsAsync.Equivalency.ConversionSelector Clone() { }
        public void Exclude(System.Linq.Expressions.Expression<System.Func<FluentAssertionsAsync.Equivalency.IObjectInfo, bool>> predicate) { }
        public void Include(System.Linq.Expressions.Expression<System.Func<FluentAssertionsAsync.Equivalency.IObjectInfo, bool>> predicate) { }
        public void IncludeAll() { }
        public bool RequiresConversion(FluentAssertionsAsync.Equivalency.Comparands comparands, FluentAssertionsAsync.Equivalency.INode currentNode) { }
        public override string ToString() { }
    }
    public enum CyclicReferenceHandling
    {
        Ignore = 0,
        ThrowException = 1,
    }
    public enum EnumEquivalencyHandling
    {
        ByValue = 0,
        ByName = 1,
    }
    public enum EqualityStrategy
    {
        Equals = 0,
        Members = 1,
        ForceEquals = 2,
        ForceMembers = 3,
    }
    public class EquivalencyOptions : FluentAssertionsAsync.Equivalency.SelfReferenceEquivalencyOptions<FluentAssertionsAsync.Equivalency.EquivalencyOptions>
    {
        public EquivalencyOptions() { }
    }
    public class EquivalencyOptions<TExpectation> : FluentAssertionsAsync.Equivalency.SelfReferenceEquivalencyOptions<FluentAssertionsAsync.Equivalency.EquivalencyOptions<TExpectation>>
    {
        public EquivalencyOptions() { }
        public EquivalencyOptions(FluentAssertionsAsync.Equivalency.IEquivalencyOptions defaults) { }
        public FluentAssertionsAsync.Equivalency.EquivalencyOptions<System.Collections.Generic.IEnumerable<TExpectation>> AsCollection() { }
        public FluentAssertionsAsync.Equivalency.EquivalencyOptions<TExpectation> Excluding(System.Linq.Expressions.Expression<System.Func<TExpectation, object>> expression) { }
        public FluentAssertionsAsync.Equivalency.NestedExclusionOptionBuilder<TExpectation, TNext> For<TNext>(System.Linq.Expressions.Expression<System.Func<TExpectation, System.Collections.Generic.IEnumerable<TNext>>> expression) { }
        public FluentAssertionsAsync.Equivalency.EquivalencyOptions<TExpectation> Including(System.Linq.Expressions.Expression<System.Func<TExpectation, object>> expression) { }
        public FluentAssertionsAsync.Equivalency.EquivalencyOptions<TExpectation> WithMapping(string expectationMemberPath, string subjectMemberPath) { }
        public FluentAssertionsAsync.Equivalency.EquivalencyOptions<TExpectation> WithMapping<TSubject>(System.Linq.Expressions.Expression<System.Func<TExpectation, object>> expectationMemberPath, System.Linq.Expressions.Expression<System.Func<TSubject, object>> subjectMemberPath) { }
        public FluentAssertionsAsync.Equivalency.EquivalencyOptions<TExpectation> WithMapping<TNestedExpectation, TNestedSubject>(System.Linq.Expressions.Expression<System.Func<TNestedExpectation, object>> expectationMember, System.Linq.Expressions.Expression<System.Func<TNestedSubject, object>> subjectMember) { }
        public FluentAssertionsAsync.Equivalency.EquivalencyOptions<TExpectation> WithMapping<TNestedExpectation, TNestedSubject>(string expectationMemberName, string subjectMemberName) { }
        public FluentAssertionsAsync.Equivalency.EquivalencyOptions<TExpectation> WithStrictOrderingFor(System.Linq.Expressions.Expression<System.Func<TExpectation, object>> expression) { }
        public FluentAssertionsAsync.Equivalency.EquivalencyOptions<TExpectation> WithoutStrictOrderingFor(System.Linq.Expressions.Expression<System.Func<TExpectation, object>> expression) { }
    }
    public enum EquivalencyResult
    {
        ContinueWithNext = 0,
        AssertionCompleted = 1,
    }
    public abstract class EquivalencyStep<T> : FluentAssertionsAsync.Equivalency.IEquivalencyStep
    {
        protected EquivalencyStep() { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.Equivalency.EquivalencyResult> HandleAsync(FluentAssertionsAsync.Equivalency.Comparands comparands, FluentAssertionsAsync.Equivalency.IEquivalencyValidationContext context, FluentAssertionsAsync.Equivalency.IEquivalencyValidator nestedValidator) { }
        protected abstract System.Threading.Tasks.Task<FluentAssertionsAsync.Equivalency.EquivalencyResult> OnHandleAsync(FluentAssertionsAsync.Equivalency.Comparands comparands, FluentAssertionsAsync.Equivalency.IEquivalencyValidationContext context, FluentAssertionsAsync.Equivalency.IEquivalencyValidator nestedValidator);
    }
    public class EquivalencyValidationContext : FluentAssertionsAsync.Equivalency.IEquivalencyValidationContext
    {
        public EquivalencyValidationContext(FluentAssertionsAsync.Equivalency.INode root, FluentAssertionsAsync.Equivalency.IEquivalencyOptions options) { }
        public FluentAssertionsAsync.Equivalency.INode CurrentNode { get; }
        public FluentAssertionsAsync.Equivalency.IEquivalencyOptions Options { get; }
        public FluentAssertionsAsync.Execution.Reason Reason { get; set; }
        public FluentAssertionsAsync.Equivalency.Tracing.ITraceWriter TraceWriter { get; set; }
        public FluentAssertionsAsync.Equivalency.Tracing.Tracer Tracer { get; }
        public FluentAssertionsAsync.Equivalency.IEquivalencyValidationContext AsCollectionItem<TItem>(string index) { }
        public FluentAssertionsAsync.Equivalency.IEquivalencyValidationContext AsDictionaryItem<TKey, TExpectation>(TKey key) { }
        public FluentAssertionsAsync.Equivalency.IEquivalencyValidationContext AsNestedMember(FluentAssertionsAsync.Equivalency.IMember expectationMember) { }
        public FluentAssertionsAsync.Equivalency.IEquivalencyValidationContext Clone() { }
        public bool IsCyclicReference(object expectation) { }
        public override string ToString() { }
    }
    public class EquivalencyValidator : FluentAssertionsAsync.Equivalency.IEquivalencyValidator
    {
        public EquivalencyValidator() { }
        public System.Threading.Tasks.Task AssertEqualityAsync(FluentAssertionsAsync.Equivalency.Comparands comparands, FluentAssertionsAsync.Equivalency.EquivalencyValidationContext context) { }
        public System.Threading.Tasks.Task RecursivelyAssertEqualityAsync(FluentAssertionsAsync.Equivalency.Comparands comparands, FluentAssertionsAsync.Equivalency.IEquivalencyValidationContext context) { }
    }
    public class Field : FluentAssertionsAsync.Equivalency.Node, FluentAssertionsAsync.Equivalency.IMember, FluentAssertionsAsync.Equivalency.INode
    {
        public Field(System.Reflection.FieldInfo fieldInfo, FluentAssertionsAsync.Equivalency.INode parent) { }
        public Field(System.Type reflectedType, System.Reflection.FieldInfo fieldInfo, FluentAssertionsAsync.Equivalency.INode parent) { }
        public System.Type DeclaringType { get; set; }
        public override string Description { get; }
        public FluentAssertionsAsync.Common.CSharpAccessModifier GetterAccessibility { get; }
        public bool IsBrowsable { get; }
        public System.Type ReflectedType { get; }
        public FluentAssertionsAsync.Common.CSharpAccessModifier SetterAccessibility { get; }
        public object GetValue(object obj) { }
    }
    public delegate string GetSubjectId();
    public interface IAssertionContext<TSubject>
    {
        string Because { get; set; }
        object[] BecauseArgs { get; set; }
        TSubject Expectation { get; }
        FluentAssertionsAsync.Equivalency.INode SelectedNode { get; }
        TSubject Subject { get; }
    }
    public interface IEquivalencyOptions
    {
        bool AllowInfiniteRecursion { get; }
        bool? CompareRecordsByValue { get; }
        FluentAssertionsAsync.Equivalency.ConversionSelector ConversionSelector { get; }
        FluentAssertionsAsync.Equivalency.CyclicReferenceHandling CyclicReferenceHandling { get; }
        FluentAssertionsAsync.Equivalency.EnumEquivalencyHandling EnumEquivalencyHandling { get; }
        bool ExcludeNonBrowsableOnExpectation { get; }
        bool IgnoreNonBrowsableOnSubject { get; }
        FluentAssertionsAsync.Equivalency.MemberVisibility IncludedFields { get; }
        FluentAssertionsAsync.Equivalency.MemberVisibility IncludedProperties { get; }
        bool IsRecursive { get; }
        System.Collections.Generic.IEnumerable<FluentAssertionsAsync.Equivalency.IMemberMatchingRule> MatchingRules { get; }
        FluentAssertionsAsync.Equivalency.OrderingRuleCollection OrderingRules { get; }
        System.Collections.Generic.IEnumerable<FluentAssertionsAsync.Equivalency.IMemberSelectionRule> SelectionRules { get; }
        FluentAssertionsAsync.Equivalency.Tracing.ITraceWriter TraceWriter { get; }
        bool UseRuntimeTyping { get; }
        System.Collections.Generic.IEnumerable<FluentAssertionsAsync.Equivalency.IEquivalencyStep> UserEquivalencySteps { get; }
        FluentAssertionsAsync.Equivalency.EqualityStrategy GetEqualityStrategy(System.Type type);
    }
    public interface IEquivalencyStep
    {
        System.Threading.Tasks.Task<FluentAssertionsAsync.Equivalency.EquivalencyResult> HandleAsync(FluentAssertionsAsync.Equivalency.Comparands comparands, FluentAssertionsAsync.Equivalency.IEquivalencyValidationContext context, FluentAssertionsAsync.Equivalency.IEquivalencyValidator nestedValidator);
    }
    public interface IEquivalencyValidationContext
    {
        FluentAssertionsAsync.Equivalency.INode CurrentNode { get; }
        FluentAssertionsAsync.Equivalency.IEquivalencyOptions Options { get; }
        FluentAssertionsAsync.Execution.Reason Reason { get; }
        FluentAssertionsAsync.Equivalency.Tracing.Tracer Tracer { get; }
        FluentAssertionsAsync.Equivalency.IEquivalencyValidationContext AsCollectionItem<TItem>(string index);
        FluentAssertionsAsync.Equivalency.IEquivalencyValidationContext AsDictionaryItem<TKey, TExpectation>(TKey key);
        FluentAssertionsAsync.Equivalency.IEquivalencyValidationContext AsNestedMember(FluentAssertionsAsync.Equivalency.IMember expectationMember);
        FluentAssertionsAsync.Equivalency.IEquivalencyValidationContext Clone();
        bool IsCyclicReference(object expectation);
    }
    public interface IEquivalencyValidator
    {
        System.Threading.Tasks.Task RecursivelyAssertEqualityAsync(FluentAssertionsAsync.Equivalency.Comparands comparands, FluentAssertionsAsync.Equivalency.IEquivalencyValidationContext context);
    }
    public interface IMember : FluentAssertionsAsync.Equivalency.INode
    {
        System.Type DeclaringType { get; }
        FluentAssertionsAsync.Common.CSharpAccessModifier GetterAccessibility { get; }
        bool IsBrowsable { get; }
        System.Type ReflectedType { get; }
        FluentAssertionsAsync.Common.CSharpAccessModifier SetterAccessibility { get; }
        object GetValue(object obj);
    }
    public interface IMemberInfo
    {
        System.Type DeclaringType { get; }
        FluentAssertionsAsync.Common.CSharpAccessModifier GetterAccessibility { get; }
        string Name { get; }
        string Path { get; set; }
        FluentAssertionsAsync.Common.CSharpAccessModifier SetterAccessibility { get; }
        System.Type Type { get; }
    }
    public interface IMemberMatchingRule
    {
        FluentAssertionsAsync.Equivalency.IMember Match(FluentAssertionsAsync.Equivalency.IMember expectedMember, object subject, FluentAssertionsAsync.Equivalency.INode parent, FluentAssertionsAsync.Equivalency.IEquivalencyOptions options);
    }
    public interface IMemberSelectionRule
    {
        bool IncludesMembers { get; }
        System.Collections.Generic.IEnumerable<FluentAssertionsAsync.Equivalency.IMember> SelectMembers(FluentAssertionsAsync.Equivalency.INode currentNode, System.Collections.Generic.IEnumerable<FluentAssertionsAsync.Equivalency.IMember> selectedMembers, FluentAssertionsAsync.Equivalency.MemberSelectionContext context);
    }
    public interface INode
    {
        int Depth { get; }
        string Description { get; }
        FluentAssertionsAsync.Equivalency.GetSubjectId GetSubjectId { get; }
        bool IsRoot { get; }
        string Name { get; set; }
        System.Type ParentType { get; }
        string Path { get; }
        string PathAndName { get; }
        bool RootIsCollection { get; }
        System.Type Type { get; }
    }
    public interface IObjectInfo
    {
        System.Type CompileTimeType { get; }
        System.Type ParentType { get; }
        string Path { get; set; }
        System.Type RuntimeType { get; }
        [System.Obsolete("Use CompileTimeType or RuntimeType instead")]
        System.Type Type { get; }
    }
    public interface IOrderingRule
    {
        FluentAssertionsAsync.Equivalency.OrderStrictness Evaluate(FluentAssertionsAsync.Equivalency.IObjectInfo objectInfo);
    }
    public static class MemberFactory
    {
        public static FluentAssertionsAsync.Equivalency.IMember Create(System.Reflection.MemberInfo memberInfo, FluentAssertionsAsync.Equivalency.INode parent) { }
    }
    public class MemberSelectionContext
    {
        public MemberSelectionContext(System.Type compileTimeType, System.Type runtimeType, FluentAssertionsAsync.Equivalency.IEquivalencyOptions options) { }
        public FluentAssertionsAsync.Equivalency.MemberVisibility IncludedFields { get; }
        public FluentAssertionsAsync.Equivalency.MemberVisibility IncludedProperties { get; }
        public System.Type Type { get; }
    }
    [System.Flags]
    public enum MemberVisibility
    {
        None = 0,
        Internal = 1,
        Public = 2,
        ExplicitlyImplemented = 4,
    }
    public class NestedExclusionOptionBuilder<TExpectation, TCurrent>
    {
        public FluentAssertionsAsync.Equivalency.EquivalencyOptions<TExpectation> Exclude(System.Linq.Expressions.Expression<System.Func<TCurrent, object>> expression) { }
        public FluentAssertionsAsync.Equivalency.NestedExclusionOptionBuilder<TExpectation, TNext> For<TNext>(System.Linq.Expressions.Expression<System.Func<TCurrent, System.Collections.Generic.IEnumerable<TNext>>> expression) { }
    }
    public class Node : FluentAssertionsAsync.Equivalency.INode
    {
        public Node() { }
        public int Depth { get; }
        public virtual string Description { get; }
        public FluentAssertionsAsync.Equivalency.GetSubjectId GetSubjectId { get; set; }
        public bool IsRoot { get; }
        public string Name { get; set; }
        public System.Type ParentType { get; set; }
        public string Path { get; set; }
        public string PathAndName { get; }
        public bool RootIsCollection { get; set; }
        public System.Type Type { get; set; }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public override string ToString() { }
        public static FluentAssertionsAsync.Equivalency.INode From<T>(FluentAssertionsAsync.Equivalency.GetSubjectId getSubjectId) { }
        public static FluentAssertionsAsync.Equivalency.INode FromCollectionItem<T>(string index, FluentAssertionsAsync.Equivalency.INode parent) { }
        public static FluentAssertionsAsync.Equivalency.INode FromDictionaryItem<T>(object key, FluentAssertionsAsync.Equivalency.INode parent) { }
    }
    public enum OrderStrictness
    {
        Strict = 0,
        NotStrict = 1,
        Irrelevant = 2,
    }
    public class OrderingRuleCollection : System.Collections.Generic.IEnumerable<FluentAssertionsAsync.Equivalency.IOrderingRule>, System.Collections.IEnumerable
    {
        public OrderingRuleCollection() { }
        public OrderingRuleCollection(System.Collections.Generic.IEnumerable<FluentAssertionsAsync.Equivalency.IOrderingRule> orderingRules) { }
        public void Add(FluentAssertionsAsync.Equivalency.IOrderingRule rule) { }
        public System.Collections.Generic.IEnumerator<FluentAssertionsAsync.Equivalency.IOrderingRule> GetEnumerator() { }
        public bool IsOrderingStrictFor(FluentAssertionsAsync.Equivalency.IObjectInfo objectInfo) { }
    }
    public class Property : FluentAssertionsAsync.Equivalency.Node, FluentAssertionsAsync.Equivalency.IMember, FluentAssertionsAsync.Equivalency.INode
    {
        public Property(System.Reflection.PropertyInfo propertyInfo, FluentAssertionsAsync.Equivalency.INode parent) { }
        public Property(System.Type reflectedType, System.Reflection.PropertyInfo propertyInfo, FluentAssertionsAsync.Equivalency.INode parent) { }
        public System.Type DeclaringType { get; }
        public override string Description { get; }
        public FluentAssertionsAsync.Common.CSharpAccessModifier GetterAccessibility { get; }
        public bool IsBrowsable { get; }
        public System.Type ReflectedType { get; }
        public FluentAssertionsAsync.Common.CSharpAccessModifier SetterAccessibility { get; }
        public object GetValue(object obj) { }
    }
    public abstract class SelfReferenceEquivalencyOptions<TSelf> : FluentAssertionsAsync.Equivalency.IEquivalencyOptions
        where TSelf : FluentAssertionsAsync.Equivalency.SelfReferenceEquivalencyOptions<TSelf>
    {
        protected SelfReferenceEquivalencyOptions(FluentAssertionsAsync.Equivalency.IEquivalencyOptions defaults) { }
        public bool? CompareRecordsByValue { get; }
        public FluentAssertionsAsync.Equivalency.ConversionSelector ConversionSelector { get; }
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        protected FluentAssertionsAsync.Equivalency.OrderingRuleCollection OrderingRules { get; }
        public FluentAssertionsAsync.Equivalency.Tracing.ITraceWriter TraceWriter { get; }
        protected TSelf AddMatchingRule(FluentAssertionsAsync.Equivalency.IMemberMatchingRule matchingRule) { }
        protected TSelf AddSelectionRule(FluentAssertionsAsync.Equivalency.IMemberSelectionRule selectionRule) { }
        public TSelf AllowingInfiniteRecursion() { }
        public TSelf ComparingByMembers(System.Type type) { }
        public TSelf ComparingByMembers<T>() { }
        public TSelf ComparingByValue(System.Type type) { }
        public TSelf ComparingByValue<T>() { }
        public TSelf ComparingEnumsByName() { }
        public TSelf ComparingEnumsByValue() { }
        public TSelf ComparingRecordsByMembers() { }
        public TSelf ComparingRecordsByValue() { }
        public TSelf Excluding(System.Linq.Expressions.Expression<System.Func<FluentAssertionsAsync.Equivalency.IMemberInfo, bool>> predicate) { }
        public TSelf ExcludingFields() { }
        public TSelf ExcludingMissingMembers() { }
        public TSelf ExcludingNestedObjects() { }
        public TSelf ExcludingNonBrowsableMembers() { }
        public TSelf ExcludingProperties() { }
        public TSelf IgnoringCyclicReferences() { }
        public TSelf IgnoringNonBrowsableMembersOnSubject() { }
        public TSelf Including(System.Linq.Expressions.Expression<System.Func<FluentAssertionsAsync.Equivalency.IMemberInfo, bool>> predicate) { }
        public TSelf IncludingAllDeclaredProperties() { }
        public TSelf IncludingAllRuntimeProperties() { }
        public TSelf IncludingFields() { }
        public TSelf IncludingInternalFields() { }
        public TSelf IncludingInternalProperties() { }
        public TSelf IncludingNestedObjects() { }
        public TSelf IncludingProperties() { }
        public TSelf RespectingDeclaredTypes() { }
        public TSelf RespectingRuntimeTypes() { }
        public TSelf ThrowingOnMissingMembers() { }
        public override string ToString() { }
        public TSelf Using(FluentAssertionsAsync.Equivalency.IEquivalencyStep equivalencyStep) { }
        public TSelf Using(FluentAssertionsAsync.Equivalency.IMemberMatchingRule matchingRule) { }
        public TSelf Using(FluentAssertionsAsync.Equivalency.IMemberSelectionRule selectionRule) { }
        public TSelf Using(FluentAssertionsAsync.Equivalency.IOrderingRule orderingRule) { }
        public FluentAssertionsAsync.Equivalency.SelfReferenceEquivalencyOptions<TSelf>.Restriction<TProperty> Using<TProperty>(System.Action<FluentAssertionsAsync.Equivalency.IAssertionContext<TProperty>> action) { }
        public TSelf Using<T>(System.Collections.Generic.IEqualityComparer<T> comparer) { }
        public FluentAssertionsAsync.Equivalency.SelfReferenceEquivalencyOptions<TSelf>.RestrictionAsync<TProperty> Using<TProperty>(System.Func<FluentAssertionsAsync.Equivalency.IAssertionContext<TProperty>, System.Threading.Tasks.Task> action) { }
        public TSelf Using<T, TEqualityComparer>()
            where TEqualityComparer : System.Collections.Generic.IEqualityComparer<T>, new () { }
        public TSelf WithAutoConversion() { }
        public TSelf WithAutoConversionFor(System.Linq.Expressions.Expression<System.Func<FluentAssertionsAsync.Equivalency.IObjectInfo, bool>> predicate) { }
        public TSelf WithStrictOrdering() { }
        public TSelf WithStrictOrderingFor(System.Linq.Expressions.Expression<System.Func<FluentAssertionsAsync.Equivalency.IObjectInfo, bool>> predicate) { }
        public TSelf WithTracing(FluentAssertionsAsync.Equivalency.Tracing.ITraceWriter writer = null) { }
        public TSelf WithoutAutoConversionFor(System.Linq.Expressions.Expression<System.Func<FluentAssertionsAsync.Equivalency.IObjectInfo, bool>> predicate) { }
        public TSelf WithoutMatchingRules() { }
        public TSelf WithoutSelectionRules() { }
        public TSelf WithoutStrictOrdering() { }
        public TSelf WithoutStrictOrderingFor(System.Linq.Expressions.Expression<System.Func<FluentAssertionsAsync.Equivalency.IObjectInfo, bool>> predicate) { }
        public class Restriction<TMember>
        {
            public Restriction(TSelf options, System.Action<FluentAssertionsAsync.Equivalency.IAssertionContext<TMember>> action) { }
            public TSelf When(System.Linq.Expressions.Expression<System.Func<FluentAssertionsAsync.Equivalency.IObjectInfo, bool>> predicate) { }
            public TSelf WhenTypeIs<TMemberType>()
                where TMemberType : TMember { }
        }
        public class RestrictionAsync<TMember>
        {
            public RestrictionAsync(TSelf options, System.Func<FluentAssertionsAsync.Equivalency.IAssertionContext<TMember>, System.Threading.Tasks.Task> action) { }
            public TSelf When(System.Linq.Expressions.Expression<System.Func<FluentAssertionsAsync.Equivalency.IObjectInfo, bool>> predicate) { }
            public TSelf WhenTypeIs<TMemberType>()
                where TMemberType : TMember { }
        }
    }
    public static class SubjectInfoExtensions
    {
        public static bool WhichGetterDoesNotHave(this FluentAssertionsAsync.Equivalency.IMemberInfo memberInfo, FluentAssertionsAsync.Common.CSharpAccessModifier accessModifier) { }
        public static bool WhichGetterHas(this FluentAssertionsAsync.Equivalency.IMemberInfo memberInfo, FluentAssertionsAsync.Common.CSharpAccessModifier accessModifier) { }
        public static bool WhichSetterDoesNotHave(this FluentAssertionsAsync.Equivalency.IMemberInfo memberInfo, FluentAssertionsAsync.Common.CSharpAccessModifier accessModifier) { }
        public static bool WhichSetterHas(this FluentAssertionsAsync.Equivalency.IMemberInfo memberInfo, FluentAssertionsAsync.Common.CSharpAccessModifier accessModifier) { }
    }
}
namespace FluentAssertionsAsync.Equivalency.Steps
{
    public class AssertionRuleEquivalencyStepAsync<TSubject> : FluentAssertionsAsync.Equivalency.IEquivalencyStep
    {
        public AssertionRuleEquivalencyStepAsync(System.Linq.Expressions.Expression<System.Func<FluentAssertionsAsync.Equivalency.IObjectInfo, bool>> predicate, System.Func<FluentAssertionsAsync.Equivalency.IAssertionContext<TSubject>, System.Threading.Tasks.Task> assertion) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.Equivalency.EquivalencyResult> HandleAsync(FluentAssertionsAsync.Equivalency.Comparands comparands, FluentAssertionsAsync.Equivalency.IEquivalencyValidationContext context, FluentAssertionsAsync.Equivalency.IEquivalencyValidator nestedValidator) { }
        public override string ToString() { }
    }
    public class AssertionRuleEquivalencyStep<TSubject> : FluentAssertionsAsync.Equivalency.IEquivalencyStep
    {
        public AssertionRuleEquivalencyStep(System.Linq.Expressions.Expression<System.Func<FluentAssertionsAsync.Equivalency.IObjectInfo, bool>> predicate, System.Action<FluentAssertionsAsync.Equivalency.IAssertionContext<TSubject>> assertion) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.Equivalency.EquivalencyResult> HandleAsync(FluentAssertionsAsync.Equivalency.Comparands comparands, FluentAssertionsAsync.Equivalency.IEquivalencyValidationContext context, FluentAssertionsAsync.Equivalency.IEquivalencyValidator nestedValidator) { }
        public override string ToString() { }
    }
    public class AsyncEnumerableEquivalencyStep : FluentAssertionsAsync.Equivalency.IEquivalencyStep
    {
        public AsyncEnumerableEquivalencyStep() { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.Equivalency.EquivalencyResult> HandleAsync(FluentAssertionsAsync.Equivalency.Comparands comparands, FluentAssertionsAsync.Equivalency.IEquivalencyValidationContext context, FluentAssertionsAsync.Equivalency.IEquivalencyValidator nestedValidator) { }
    }
    public class AutoConversionStep : FluentAssertionsAsync.Equivalency.IEquivalencyStep
    {
        public AutoConversionStep() { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.Equivalency.EquivalencyResult> HandleAsync(FluentAssertionsAsync.Equivalency.Comparands comparands, FluentAssertionsAsync.Equivalency.IEquivalencyValidationContext context, FluentAssertionsAsync.Equivalency.IEquivalencyValidator nestedValidator) { }
        public override string ToString() { }
    }
    public class DictionaryEquivalencyStep : FluentAssertionsAsync.Equivalency.EquivalencyStep<System.Collections.IDictionary>
    {
        public DictionaryEquivalencyStep() { }
        protected override System.Threading.Tasks.Task<FluentAssertionsAsync.Equivalency.EquivalencyResult> OnHandleAsync(FluentAssertionsAsync.Equivalency.Comparands comparands, FluentAssertionsAsync.Equivalency.IEquivalencyValidationContext context, FluentAssertionsAsync.Equivalency.IEquivalencyValidator nestedValidator) { }
    }
    public class EnumEqualityStep : FluentAssertionsAsync.Equivalency.IEquivalencyStep
    {
        public EnumEqualityStep() { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.Equivalency.EquivalencyResult> HandleAsync(FluentAssertionsAsync.Equivalency.Comparands comparands, FluentAssertionsAsync.Equivalency.IEquivalencyValidationContext context, FluentAssertionsAsync.Equivalency.IEquivalencyValidator nestedValidator) { }
    }
    public class EnumerableEquivalencyStep : FluentAssertionsAsync.Equivalency.IEquivalencyStep
    {
        public EnumerableEquivalencyStep() { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.Equivalency.EquivalencyResult> HandleAsync(FluentAssertionsAsync.Equivalency.Comparands comparands, FluentAssertionsAsync.Equivalency.IEquivalencyValidationContext context, FluentAssertionsAsync.Equivalency.IEquivalencyValidator nestedValidator) { }
    }
    public class EqualityComparerEquivalencyStep<T> : FluentAssertionsAsync.Equivalency.IEquivalencyStep
    {
        public EqualityComparerEquivalencyStep(System.Collections.Generic.IEqualityComparer<T> comparer) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.Equivalency.EquivalencyResult> HandleAsync(FluentAssertionsAsync.Equivalency.Comparands comparands, FluentAssertionsAsync.Equivalency.IEquivalencyValidationContext context, FluentAssertionsAsync.Equivalency.IEquivalencyValidator nestedValidator) { }
        public override string ToString() { }
    }
    public class GenericDictionaryEquivalencyStep : FluentAssertionsAsync.Equivalency.IEquivalencyStep
    {
        public GenericDictionaryEquivalencyStep() { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.Equivalency.EquivalencyResult> HandleAsync(FluentAssertionsAsync.Equivalency.Comparands comparands, FluentAssertionsAsync.Equivalency.IEquivalencyValidationContext context, FluentAssertionsAsync.Equivalency.IEquivalencyValidator nestedValidator) { }
    }
    public class GenericEnumerableEquivalencyStep : FluentAssertionsAsync.Equivalency.IEquivalencyStep
    {
        public GenericEnumerableEquivalencyStep() { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.Equivalency.EquivalencyResult> HandleAsync(FluentAssertionsAsync.Equivalency.Comparands comparands, FluentAssertionsAsync.Equivalency.IEquivalencyValidationContext context, FluentAssertionsAsync.Equivalency.IEquivalencyValidator nestedValidator) { }
    }
    public class ReferenceEqualityEquivalencyStep : FluentAssertionsAsync.Equivalency.IEquivalencyStep
    {
        public ReferenceEqualityEquivalencyStep() { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.Equivalency.EquivalencyResult> HandleAsync(FluentAssertionsAsync.Equivalency.Comparands comparands, FluentAssertionsAsync.Equivalency.IEquivalencyValidationContext context, FluentAssertionsAsync.Equivalency.IEquivalencyValidator nestedValidator) { }
    }
    public class RunAllUserStepsEquivalencyStep : FluentAssertionsAsync.Equivalency.IEquivalencyStep
    {
        public RunAllUserStepsEquivalencyStep() { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.Equivalency.EquivalencyResult> HandleAsync(FluentAssertionsAsync.Equivalency.Comparands comparands, FluentAssertionsAsync.Equivalency.IEquivalencyValidationContext context, FluentAssertionsAsync.Equivalency.IEquivalencyValidator nestedValidator) { }
    }
    public class SimpleEqualityEquivalencyStep : FluentAssertionsAsync.Equivalency.IEquivalencyStep
    {
        public SimpleEqualityEquivalencyStep() { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.Equivalency.EquivalencyResult> HandleAsync(FluentAssertionsAsync.Equivalency.Comparands comparands, FluentAssertionsAsync.Equivalency.IEquivalencyValidationContext context, FluentAssertionsAsync.Equivalency.IEquivalencyValidator nestedValidator) { }
    }
    public class StringEqualityEquivalencyStep : FluentAssertionsAsync.Equivalency.IEquivalencyStep
    {
        public StringEqualityEquivalencyStep() { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.Equivalency.EquivalencyResult> HandleAsync(FluentAssertionsAsync.Equivalency.Comparands comparands, FluentAssertionsAsync.Equivalency.IEquivalencyValidationContext context, FluentAssertionsAsync.Equivalency.IEquivalencyValidator nestedValidator) { }
    }
    public class StructuralEqualityEquivalencyStep : FluentAssertionsAsync.Equivalency.IEquivalencyStep
    {
        public StructuralEqualityEquivalencyStep() { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.Equivalency.EquivalencyResult> HandleAsync(FluentAssertionsAsync.Equivalency.Comparands comparands, FluentAssertionsAsync.Equivalency.IEquivalencyValidationContext context, FluentAssertionsAsync.Equivalency.IEquivalencyValidator nestedValidator) { }
    }
    public class ValueTypeEquivalencyStep : FluentAssertionsAsync.Equivalency.IEquivalencyStep
    {
        public ValueTypeEquivalencyStep() { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.Equivalency.EquivalencyResult> HandleAsync(FluentAssertionsAsync.Equivalency.Comparands comparands, FluentAssertionsAsync.Equivalency.IEquivalencyValidationContext context, FluentAssertionsAsync.Equivalency.IEquivalencyValidator nestedValidator) { }
    }
    public class XAttributeEquivalencyStep : FluentAssertionsAsync.Equivalency.EquivalencyStep<System.Xml.Linq.XAttribute>
    {
        public XAttributeEquivalencyStep() { }
        protected override System.Threading.Tasks.Task<FluentAssertionsAsync.Equivalency.EquivalencyResult> OnHandleAsync(FluentAssertionsAsync.Equivalency.Comparands comparands, FluentAssertionsAsync.Equivalency.IEquivalencyValidationContext context, FluentAssertionsAsync.Equivalency.IEquivalencyValidator nestedValidator) { }
    }
    public class XDocumentEquivalencyStep : FluentAssertionsAsync.Equivalency.EquivalencyStep<System.Xml.Linq.XDocument>
    {
        public XDocumentEquivalencyStep() { }
        protected override System.Threading.Tasks.Task<FluentAssertionsAsync.Equivalency.EquivalencyResult> OnHandleAsync(FluentAssertionsAsync.Equivalency.Comparands comparands, FluentAssertionsAsync.Equivalency.IEquivalencyValidationContext context, FluentAssertionsAsync.Equivalency.IEquivalencyValidator nestedValidator) { }
    }
    public class XElementEquivalencyStep : FluentAssertionsAsync.Equivalency.EquivalencyStep<System.Xml.Linq.XElement>
    {
        public XElementEquivalencyStep() { }
        protected override System.Threading.Tasks.Task<FluentAssertionsAsync.Equivalency.EquivalencyResult> OnHandleAsync(FluentAssertionsAsync.Equivalency.Comparands comparands, FluentAssertionsAsync.Equivalency.IEquivalencyValidationContext context, FluentAssertionsAsync.Equivalency.IEquivalencyValidator nestedValidator) { }
    }
}
namespace FluentAssertionsAsync.Equivalency.Tracing
{
    public delegate string GetTraceMessage(FluentAssertionsAsync.Equivalency.INode node);
    public interface ITraceWriter
    {
        System.IDisposable AddBlock(string trace);
        void AddSingle(string trace);
        string ToString();
    }
    public class StringBuilderTraceWriter : FluentAssertionsAsync.Equivalency.Tracing.ITraceWriter
    {
        public StringBuilderTraceWriter() { }
        public System.IDisposable AddBlock(string trace) { }
        public void AddSingle(string trace) { }
        public override string ToString() { }
    }
    public class Tracer
    {
        public override string ToString() { }
        public System.IDisposable WriteBlock(FluentAssertionsAsync.Equivalency.Tracing.GetTraceMessage getTraceMessage) { }
        public void WriteLine(FluentAssertionsAsync.Equivalency.Tracing.GetTraceMessage getTraceMessage) { }
    }
}
namespace FluentAssertionsAsync.Execution
{
    [System.Serializable]
    public class AssertionFailedException : System.Exception
    {
        public AssertionFailedException(string message) { }
        protected AssertionFailedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
    }
    public sealed class AssertionScope : FluentAssertionsAsync.Execution.IAssertionScope, System.IDisposable
    {
        public AssertionScope() { }
        public AssertionScope(FluentAssertionsAsync.Execution.IAssertionStrategy assertionStrategy) { }
        public AssertionScope(System.Lazy<string> context) { }
        public AssertionScope(string context) { }
        public string CallerIdentity { get; }
        public System.Lazy<string> Context { get; set; }
        public FluentAssertionsAsync.Formatting.FormattingOptions FormattingOptions { get; }
        public FluentAssertionsAsync.Execution.AssertionScope UsingLineBreaks { get; }
        public static FluentAssertionsAsync.Execution.AssertionScope Current { get; }
        public void AddNonReportable(string key, object value) { }
        public void AddPreFormattedFailure(string formattedFailureMessage) { }
        public void AddReportable(string key, System.Func<string> valueFunc) { }
        public void AddReportable(string key, string value) { }
        public void AppendTracing(string tracingBlock) { }
        public void AssumeSingleCaller() { }
        public FluentAssertionsAsync.Execution.AssertionScope BecauseOf(FluentAssertionsAsync.Execution.Reason reason) { }
        public FluentAssertionsAsync.Execution.AssertionScope BecauseOf(string because, params object[] becauseArgs) { }
        public FluentAssertionsAsync.Execution.Continuation ClearExpectation() { }
        public string[] Discard() { }
        public void Dispose() { }
        public FluentAssertionsAsync.Execution.Continuation FailWith(System.Func<FluentAssertionsAsync.Execution.FailReason> failReasonFunc) { }
        public FluentAssertionsAsync.Execution.Continuation FailWith(string message) { }
        public FluentAssertionsAsync.Execution.Continuation FailWith(string message, params System.Func<object>[] argProviders) { }
        public FluentAssertionsAsync.Execution.Continuation FailWith(string message, params object[] args) { }
        public FluentAssertionsAsync.Execution.AssertionScope ForCondition(bool condition) { }
        public FluentAssertionsAsync.Execution.AssertionScope ForConstraint(FluentAssertionsAsync.OccurrenceConstraint constraint, int actualOccurrences) { }
        public T Get<T>(string key) { }
        public FluentAssertionsAsync.Execution.GivenSelector<T> Given<T>(System.Func<T> selector) { }
        public bool HasFailures() { }
        public FluentAssertionsAsync.Execution.AssertionScope WithDefaultIdentifier(string identifier) { }
        public FluentAssertionsAsync.Execution.AssertionScope WithExpectation(string message, params object[] args) { }
    }
    public class Continuation
    {
        public FluentAssertionsAsync.Execution.IAssertionScope Then { get; }
        public static bool op_Implicit(FluentAssertionsAsync.Execution.Continuation continuation) { }
    }
    public class ContinuationOfGiven<TSubject>
    {
        public FluentAssertionsAsync.Execution.GivenSelector<TSubject> Then { get; }
        public static bool op_Implicit(FluentAssertionsAsync.Execution.ContinuationOfGiven<TSubject> continuationOfGiven) { }
    }
    public sealed class ContinuedAssertionScope : FluentAssertionsAsync.Execution.IAssertionScope, System.IDisposable
    {
        public FluentAssertionsAsync.Execution.IAssertionScope UsingLineBreaks { get; }
        public FluentAssertionsAsync.Execution.IAssertionScope BecauseOf(string because, params object[] becauseArgs) { }
        public FluentAssertionsAsync.Execution.Continuation ClearExpectation() { }
        public string[] Discard() { }
        public void Dispose() { }
        public FluentAssertionsAsync.Execution.Continuation FailWith(System.Func<FluentAssertionsAsync.Execution.FailReason> failReasonFunc) { }
        public FluentAssertionsAsync.Execution.Continuation FailWith(string message) { }
        public FluentAssertionsAsync.Execution.Continuation FailWith(string message, params System.Func<object>[] argProviders) { }
        public FluentAssertionsAsync.Execution.Continuation FailWith(string message, params object[] args) { }
        public FluentAssertionsAsync.Execution.IAssertionScope ForCondition(bool condition) { }
        public FluentAssertionsAsync.Execution.IAssertionScope ForConstraint(FluentAssertionsAsync.OccurrenceConstraint constraint, int actualOccurrences) { }
        public FluentAssertionsAsync.Execution.GivenSelector<T> Given<T>(System.Func<T> selector) { }
        public FluentAssertionsAsync.Execution.IAssertionScope WithDefaultIdentifier(string identifier) { }
        public FluentAssertionsAsync.Execution.IAssertionScope WithExpectation(string message, params object[] args) { }
    }
    public static class Execute
    {
        public static FluentAssertionsAsync.Execution.AssertionScope Assertion { get; }
    }
    public class FailReason
    {
        public FailReason(string message, params object[] args) { }
        public object[] Args { get; }
        public string Message { get; }
    }
    public class GivenSelector<T>
    {
        public FluentAssertionsAsync.Execution.ContinuationOfGiven<T> ClearExpectation() { }
        public FluentAssertionsAsync.Execution.ContinuationOfGiven<T> FailWith(string message) { }
        public FluentAssertionsAsync.Execution.ContinuationOfGiven<T> FailWith(string message, params System.Func<T, object>[] args) { }
        public FluentAssertionsAsync.Execution.ContinuationOfGiven<T> FailWith(string message, params object[] args) { }
        public FluentAssertionsAsync.Execution.GivenSelector<T> ForCondition(System.Func<T, bool> predicate) { }
        public FluentAssertionsAsync.Execution.GivenSelector<TOut> Given<TOut>(System.Func<T, TOut> selector) { }
    }
    public interface IAssertionScope : System.IDisposable
    {
        FluentAssertionsAsync.Execution.IAssertionScope UsingLineBreaks { get; }
        FluentAssertionsAsync.Execution.IAssertionScope BecauseOf(string because, params object[] becauseArgs);
        FluentAssertionsAsync.Execution.Continuation ClearExpectation();
        string[] Discard();
        FluentAssertionsAsync.Execution.Continuation FailWith(System.Func<FluentAssertionsAsync.Execution.FailReason> failReasonFunc);
        FluentAssertionsAsync.Execution.Continuation FailWith(string message);
        FluentAssertionsAsync.Execution.Continuation FailWith(string message, params System.Func<object>[] argProviders);
        FluentAssertionsAsync.Execution.Continuation FailWith(string message, params object[] args);
        FluentAssertionsAsync.Execution.IAssertionScope ForCondition(bool condition);
        FluentAssertionsAsync.Execution.IAssertionScope ForConstraint(FluentAssertionsAsync.OccurrenceConstraint constraint, int actualOccurrences);
        FluentAssertionsAsync.Execution.GivenSelector<T> Given<T>(System.Func<T> selector);
        FluentAssertionsAsync.Execution.IAssertionScope WithDefaultIdentifier(string identifier);
        FluentAssertionsAsync.Execution.IAssertionScope WithExpectation(string message, params object[] args);
    }
    public interface IAssertionStrategy
    {
        System.Collections.Generic.IEnumerable<string> FailureMessages { get; }
        System.Collections.Generic.IEnumerable<string> DiscardFailures();
        void HandleFailure(string message);
        void ThrowIfAny(System.Collections.Generic.IDictionary<string, object> context);
    }
    public interface ICloneable2
    {
        object Clone();
    }
    public class Reason
    {
        public Reason(string formattedMessage, object[] arguments) { }
        public object[] Arguments { get; set; }
        public string FormattedMessage { get; set; }
    }
}
namespace FluentAssertionsAsync.Extensibility
{
    [System.AttributeUsage(System.AttributeTargets.Assembly, AllowMultiple=true)]
    public sealed class AssertionEngineInitializerAttribute : System.Attribute
    {
        public AssertionEngineInitializerAttribute(System.Type type, string methodName) { }
    }
}
namespace FluentAssertionsAsync.Extensions
{
    public static class FluentDateTimeExtensions
    {
        public static System.DateTime AddMicroseconds(this System.DateTime self, long microseconds) { }
        public static System.DateTimeOffset AddMicroseconds(this System.DateTimeOffset self, long microseconds) { }
        public static System.DateTime AddNanoseconds(this System.DateTime self, long nanoseconds) { }
        public static System.DateTimeOffset AddNanoseconds(this System.DateTimeOffset self, long nanoseconds) { }
        public static System.DateTime After(this System.TimeSpan timeDifference, System.DateTime sourceDateTime) { }
        public static System.DateTime April(this int day, int year) { }
        public static System.DateTime AsLocal(this System.DateTime dateTime) { }
        public static System.DateTime AsUtc(this System.DateTime dateTime) { }
        public static System.DateTime At(this System.DateTime date, System.TimeSpan time) { }
        public static System.DateTime At(this System.DateTime date, int hours, int minutes, int seconds = 0, int milliseconds = 0, int microseconds = 0, int nanoseconds = 0) { }
        public static System.DateTimeOffset At(this System.DateTimeOffset date, int hours, int minutes, int seconds = 0, int milliseconds = 0, int microseconds = 0, int nanoseconds = 0) { }
        public static System.DateTime August(this int day, int year) { }
        public static System.DateTime Before(this System.TimeSpan timeDifference, System.DateTime sourceDateTime) { }
        public static System.DateTime December(this int day, int year) { }
        public static System.DateTime February(this int day, int year) { }
        public static System.DateTime January(this int day, int year) { }
        public static System.DateTime July(this int day, int year) { }
        public static System.DateTime June(this int day, int year) { }
        public static System.DateTime March(this int day, int year) { }
        public static System.DateTime May(this int day, int year) { }
        public static int Microsecond(this System.DateTime self) { }
        public static int Microsecond(this System.DateTimeOffset self) { }
        public static int Nanosecond(this System.DateTime self) { }
        public static int Nanosecond(this System.DateTimeOffset self) { }
        public static System.DateTime November(this int day, int year) { }
        public static System.DateTime October(this int day, int year) { }
        public static System.DateTime September(this int day, int year) { }
        public static System.DateTimeOffset WithOffset(this System.DateTime self, System.TimeSpan offset) { }
    }
    public static class FluentTimeSpanExtensions
    {
        public const long TicksPerMicrosecond = 10;
        public const double TicksPerNanosecond = 0.01D;
        public static System.TimeSpan And(this System.TimeSpan sourceTime, System.TimeSpan offset) { }
        public static System.TimeSpan Days(this double days) { }
        public static System.TimeSpan Days(this int days) { }
        public static System.TimeSpan Days(this int days, System.TimeSpan offset) { }
        public static System.TimeSpan Hours(this double hours) { }
        public static System.TimeSpan Hours(this int hours) { }
        public static System.TimeSpan Hours(this int hours, System.TimeSpan offset) { }
        public static int Microseconds(this System.TimeSpan self) { }
        public static System.TimeSpan Microseconds(this int microseconds) { }
        public static System.TimeSpan Microseconds(this long microseconds) { }
        public static System.TimeSpan Milliseconds(this double milliseconds) { }
        public static System.TimeSpan Milliseconds(this int milliseconds) { }
        public static System.TimeSpan Minutes(this double minutes) { }
        public static System.TimeSpan Minutes(this int minutes) { }
        public static System.TimeSpan Minutes(this int minutes, System.TimeSpan offset) { }
        public static int Nanoseconds(this System.TimeSpan self) { }
        public static System.TimeSpan Nanoseconds(this int nanoseconds) { }
        public static System.TimeSpan Nanoseconds(this long nanoseconds) { }
        public static System.TimeSpan Seconds(this double seconds) { }
        public static System.TimeSpan Seconds(this int seconds) { }
        public static System.TimeSpan Seconds(this int seconds, System.TimeSpan offset) { }
        public static System.TimeSpan Ticks(this int ticks) { }
        public static System.TimeSpan Ticks(this long ticks) { }
        public static double TotalMicroseconds(this System.TimeSpan self) { }
        public static double TotalNanoseconds(this System.TimeSpan self) { }
    }
    public static class OccurrenceConstraintExtensions
    {
        public static FluentAssertionsAsync.OccurrenceConstraint TimesExactly(this int times) { }
        public static FluentAssertionsAsync.OccurrenceConstraint TimesOrLess(this int times) { }
        public static FluentAssertionsAsync.OccurrenceConstraint TimesOrMore(this int times) { }
    }
}
namespace FluentAssertionsAsync.Formatting
{
    public class AggregateExceptionValueFormatter : FluentAssertionsAsync.Formatting.IValueFormatter
    {
        public AggregateExceptionValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertionsAsync.Formatting.FormattedObjectGraph formattedGraph, FluentAssertionsAsync.Formatting.FormattingContext context, FluentAssertionsAsync.Formatting.FormatChild formatChild) { }
    }
    public class AttributeBasedFormatter : FluentAssertionsAsync.Formatting.IValueFormatter
    {
        public AttributeBasedFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertionsAsync.Formatting.FormattedObjectGraph formattedGraph, FluentAssertionsAsync.Formatting.FormattingContext context, FluentAssertionsAsync.Formatting.FormatChild formatChild) { }
    }
    public class ByteValueFormatter : FluentAssertionsAsync.Formatting.IValueFormatter
    {
        public ByteValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertionsAsync.Formatting.FormattedObjectGraph formattedGraph, FluentAssertionsAsync.Formatting.FormattingContext context, FluentAssertionsAsync.Formatting.FormatChild formatChild) { }
    }
    public class DateTimeOffsetValueFormatter : FluentAssertionsAsync.Formatting.IValueFormatter
    {
        public DateTimeOffsetValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertionsAsync.Formatting.FormattedObjectGraph formattedGraph, FluentAssertionsAsync.Formatting.FormattingContext context, FluentAssertionsAsync.Formatting.FormatChild formatChild) { }
    }
    public class DecimalValueFormatter : FluentAssertionsAsync.Formatting.IValueFormatter
    {
        public DecimalValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertionsAsync.Formatting.FormattedObjectGraph formattedGraph, FluentAssertionsAsync.Formatting.FormattingContext context, FluentAssertionsAsync.Formatting.FormatChild formatChild) { }
    }
    public class DefaultValueFormatter : FluentAssertionsAsync.Formatting.IValueFormatter
    {
        public DefaultValueFormatter() { }
        public virtual bool CanHandle(object value) { }
        public void Format(object value, FluentAssertionsAsync.Formatting.FormattedObjectGraph formattedGraph, FluentAssertionsAsync.Formatting.FormattingContext context, FluentAssertionsAsync.Formatting.FormatChild formatChild) { }
        protected virtual System.Reflection.MemberInfo[] GetMembers(System.Type type) { }
        protected virtual string TypeDisplayName(System.Type type) { }
    }
    public class DictionaryValueFormatter : FluentAssertionsAsync.Formatting.IValueFormatter
    {
        public DictionaryValueFormatter() { }
        protected virtual int MaxItems { get; }
        public virtual bool CanHandle(object value) { }
        public void Format(object value, FluentAssertionsAsync.Formatting.FormattedObjectGraph formattedGraph, FluentAssertionsAsync.Formatting.FormattingContext context, FluentAssertionsAsync.Formatting.FormatChild formatChild) { }
    }
    public class DoubleValueFormatter : FluentAssertionsAsync.Formatting.IValueFormatter
    {
        public DoubleValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertionsAsync.Formatting.FormattedObjectGraph formattedGraph, FluentAssertionsAsync.Formatting.FormattingContext context, FluentAssertionsAsync.Formatting.FormatChild formatChild) { }
    }
    public class EnumValueFormatter : FluentAssertionsAsync.Formatting.IValueFormatter
    {
        public EnumValueFormatter() { }
        public virtual bool CanHandle(object value) { }
        public void Format(object value, FluentAssertionsAsync.Formatting.FormattedObjectGraph formattedGraph, FluentAssertionsAsync.Formatting.FormattingContext context, FluentAssertionsAsync.Formatting.FormatChild formatChild) { }
    }
    public class EnumerableValueFormatter : FluentAssertionsAsync.Formatting.IValueFormatter
    {
        public EnumerableValueFormatter() { }
        protected virtual int MaxItems { get; }
        public virtual bool CanHandle(object value) { }
        public void Format(object value, FluentAssertionsAsync.Formatting.FormattedObjectGraph formattedGraph, FluentAssertionsAsync.Formatting.FormattingContext context, FluentAssertionsAsync.Formatting.FormatChild formatChild) { }
    }
    public class ExceptionValueFormatter : FluentAssertionsAsync.Formatting.IValueFormatter
    {
        public ExceptionValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertionsAsync.Formatting.FormattedObjectGraph formattedGraph, FluentAssertionsAsync.Formatting.FormattingContext context, FluentAssertionsAsync.Formatting.FormatChild formatChild) { }
    }
    public class ExpressionValueFormatter : FluentAssertionsAsync.Formatting.IValueFormatter
    {
        public ExpressionValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertionsAsync.Formatting.FormattedObjectGraph formattedGraph, FluentAssertionsAsync.Formatting.FormattingContext context, FluentAssertionsAsync.Formatting.FormatChild formatChild) { }
    }
    public delegate void FormatChild(string childPath, object value, FluentAssertionsAsync.Formatting.FormattedObjectGraph formattedGraph);
    public class FormattedObjectGraph
    {
        public FormattedObjectGraph(int maxLines) { }
        public int LineCount { get; }
        public static int SpacesPerIndentation { get; }
        public void AddFragment(string fragment) { }
        public void AddFragmentOnNewLine(string fragment) { }
        public void AddLine(string line) { }
        public override string ToString() { }
        public System.IDisposable WithIndentation() { }
    }
    public static class Formatter
    {
        public static System.Collections.Generic.IEnumerable<FluentAssertionsAsync.Formatting.IValueFormatter> Formatters { get; }
        public static void AddFormatter(FluentAssertionsAsync.Formatting.IValueFormatter formatter) { }
        public static void RemoveFormatter(FluentAssertionsAsync.Formatting.IValueFormatter formatter) { }
        public static string ToString(object value, FluentAssertionsAsync.Formatting.FormattingOptions options = null) { }
    }
    public class FormattingContext
    {
        public FormattingContext() { }
        public bool UseLineBreaks { get; set; }
    }
    public class FormattingOptions
    {
        public FormattingOptions() { }
        public int MaxDepth { get; set; }
        public int MaxLines { get; set; }
        public bool UseLineBreaks { get; set; }
    }
    public class GuidValueFormatter : FluentAssertionsAsync.Formatting.IValueFormatter
    {
        public GuidValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertionsAsync.Formatting.FormattedObjectGraph formattedGraph, FluentAssertionsAsync.Formatting.FormattingContext context, FluentAssertionsAsync.Formatting.FormatChild formatChild) { }
    }
    public interface IValueFormatter
    {
        bool CanHandle(object value);
        void Format(object value, FluentAssertionsAsync.Formatting.FormattedObjectGraph formattedGraph, FluentAssertionsAsync.Formatting.FormattingContext context, FluentAssertionsAsync.Formatting.FormatChild formatChild);
    }
    public class Int16ValueFormatter : FluentAssertionsAsync.Formatting.IValueFormatter
    {
        public Int16ValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertionsAsync.Formatting.FormattedObjectGraph formattedGraph, FluentAssertionsAsync.Formatting.FormattingContext context, FluentAssertionsAsync.Formatting.FormatChild formatChild) { }
    }
    public class Int32ValueFormatter : FluentAssertionsAsync.Formatting.IValueFormatter
    {
        public Int32ValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertionsAsync.Formatting.FormattedObjectGraph formattedGraph, FluentAssertionsAsync.Formatting.FormattingContext context, FluentAssertionsAsync.Formatting.FormatChild formatChild) { }
    }
    public class Int64ValueFormatter : FluentAssertionsAsync.Formatting.IValueFormatter
    {
        public Int64ValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertionsAsync.Formatting.FormattedObjectGraph formattedGraph, FluentAssertionsAsync.Formatting.FormattingContext context, FluentAssertionsAsync.Formatting.FormatChild formatChild) { }
    }
    public class MaxLinesExceededException : System.Exception
    {
        public MaxLinesExceededException() { }
        public MaxLinesExceededException(string message) { }
        public MaxLinesExceededException(string message, System.Exception innerException) { }
    }
    public class MultidimensionalArrayFormatter : FluentAssertionsAsync.Formatting.IValueFormatter
    {
        public MultidimensionalArrayFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertionsAsync.Formatting.FormattedObjectGraph formattedGraph, FluentAssertionsAsync.Formatting.FormattingContext context, FluentAssertionsAsync.Formatting.FormatChild formatChild) { }
    }
    public class NullValueFormatter : FluentAssertionsAsync.Formatting.IValueFormatter
    {
        public NullValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertionsAsync.Formatting.FormattedObjectGraph formattedGraph, FluentAssertionsAsync.Formatting.FormattingContext context, FluentAssertionsAsync.Formatting.FormatChild formatChild) { }
    }
    public class PredicateLambdaExpressionValueFormatter : FluentAssertionsAsync.Formatting.IValueFormatter
    {
        public PredicateLambdaExpressionValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertionsAsync.Formatting.FormattedObjectGraph formattedGraph, FluentAssertionsAsync.Formatting.FormattingContext context, FluentAssertionsAsync.Formatting.FormatChild formatChild) { }
    }
    public class PropertyInfoFormatter : FluentAssertionsAsync.Formatting.IValueFormatter
    {
        public PropertyInfoFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertionsAsync.Formatting.FormattedObjectGraph formattedGraph, FluentAssertionsAsync.Formatting.FormattingContext context, FluentAssertionsAsync.Formatting.FormatChild formatChild) { }
    }
    public class SByteValueFormatter : FluentAssertionsAsync.Formatting.IValueFormatter
    {
        public SByteValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertionsAsync.Formatting.FormattedObjectGraph formattedGraph, FluentAssertionsAsync.Formatting.FormattingContext context, FluentAssertionsAsync.Formatting.FormatChild formatChild) { }
    }
    public class SingleValueFormatter : FluentAssertionsAsync.Formatting.IValueFormatter
    {
        public SingleValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertionsAsync.Formatting.FormattedObjectGraph formattedGraph, FluentAssertionsAsync.Formatting.FormattingContext context, FluentAssertionsAsync.Formatting.FormatChild formatChild) { }
    }
    public class StringValueFormatter : FluentAssertionsAsync.Formatting.IValueFormatter
    {
        public StringValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertionsAsync.Formatting.FormattedObjectGraph formattedGraph, FluentAssertionsAsync.Formatting.FormattingContext context, FluentAssertionsAsync.Formatting.FormatChild formatChild) { }
    }
    public class TaskFormatter : FluentAssertionsAsync.Formatting.IValueFormatter
    {
        public TaskFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertionsAsync.Formatting.FormattedObjectGraph formattedGraph, FluentAssertionsAsync.Formatting.FormattingContext context, FluentAssertionsAsync.Formatting.FormatChild formatChild) { }
    }
    public class TimeSpanValueFormatter : FluentAssertionsAsync.Formatting.IValueFormatter
    {
        public TimeSpanValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertionsAsync.Formatting.FormattedObjectGraph formattedGraph, FluentAssertionsAsync.Formatting.FormattingContext context, FluentAssertionsAsync.Formatting.FormatChild formatChild) { }
    }
    public class UInt16ValueFormatter : FluentAssertionsAsync.Formatting.IValueFormatter
    {
        public UInt16ValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertionsAsync.Formatting.FormattedObjectGraph formattedGraph, FluentAssertionsAsync.Formatting.FormattingContext context, FluentAssertionsAsync.Formatting.FormatChild formatChild) { }
    }
    public class UInt32ValueFormatter : FluentAssertionsAsync.Formatting.IValueFormatter
    {
        public UInt32ValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertionsAsync.Formatting.FormattedObjectGraph formattedGraph, FluentAssertionsAsync.Formatting.FormattingContext context, FluentAssertionsAsync.Formatting.FormatChild formatChild) { }
    }
    public class UInt64ValueFormatter : FluentAssertionsAsync.Formatting.IValueFormatter
    {
        public UInt64ValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertionsAsync.Formatting.FormattedObjectGraph formattedGraph, FluentAssertionsAsync.Formatting.FormattingContext context, FluentAssertionsAsync.Formatting.FormatChild formatChild) { }
    }
    [System.AttributeUsage(System.AttributeTargets.Method)]
    public class ValueFormatterAttribute : System.Attribute
    {
        public ValueFormatterAttribute() { }
    }
    public class XAttributeValueFormatter : FluentAssertionsAsync.Formatting.IValueFormatter
    {
        public XAttributeValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertionsAsync.Formatting.FormattedObjectGraph formattedGraph, FluentAssertionsAsync.Formatting.FormattingContext context, FluentAssertionsAsync.Formatting.FormatChild formatChild) { }
    }
    public class XDocumentValueFormatter : FluentAssertionsAsync.Formatting.IValueFormatter
    {
        public XDocumentValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertionsAsync.Formatting.FormattedObjectGraph formattedGraph, FluentAssertionsAsync.Formatting.FormattingContext context, FluentAssertionsAsync.Formatting.FormatChild formatChild) { }
    }
    public class XElementValueFormatter : FluentAssertionsAsync.Formatting.IValueFormatter
    {
        public XElementValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertionsAsync.Formatting.FormattedObjectGraph formattedGraph, FluentAssertionsAsync.Formatting.FormattingContext context, FluentAssertionsAsync.Formatting.FormatChild formatChild) { }
    }
    public class XmlReaderValueFormatter : FluentAssertionsAsync.Formatting.IValueFormatter
    {
        public XmlReaderValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertionsAsync.Formatting.FormattedObjectGraph formattedGraph, FluentAssertionsAsync.Formatting.FormattingContext context, FluentAssertionsAsync.Formatting.FormatChild formatChild) { }
    }
}
namespace FluentAssertionsAsync.Numeric
{
    public class ComparableTypeAssertions<T> : FluentAssertionsAsync.Numeric.ComparableTypeAssertions<T, FluentAssertionsAsync.Numeric.ComparableTypeAssertions<T>>
    {
        public ComparableTypeAssertions(System.IComparable<T> value) { }
    }
    public class ComparableTypeAssertions<T, TAssertions> : FluentAssertionsAsync.Primitives.ReferenceTypeAssertions<System.IComparable<T>, TAssertions>
        where TAssertions : FluentAssertionsAsync.Numeric.ComparableTypeAssertions<T, TAssertions>
    {
        public ComparableTypeAssertions(System.IComparable<T> value) { }
        protected override string Identifier { get; }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Be(T expected, string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndConstraint<TAssertions>> BeEquivalentToAsync<TExpectation>(TExpectation expectation, string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndConstraint<TAssertions>> BeEquivalentToAsync<TExpectation>(TExpectation expectation, System.Func<FluentAssertionsAsync.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertionsAsync.Equivalency.EquivalencyOptions<TExpectation>> config, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeGreaterThan(T expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeGreaterThanOrEqualTo(T expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeInRange(T minimumValue, T maximumValue, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeLessThan(T expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeLessThanOrEqualTo(T expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeOneOf(params T[] validValues) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<T> validValues, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeRankedEquallyTo(T expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBe(T unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeInRange(T minimumValue, T maximumValue, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeRankedEquallyTo(T unexpected, string because = "", params object[] becauseArgs) { }
    }
    public class NullableNumericAssertions<T> : FluentAssertionsAsync.Numeric.NullableNumericAssertions<T, FluentAssertionsAsync.Numeric.NullableNumericAssertions<T>>
        where T :  struct, System.IComparable<T>
    {
        public NullableNumericAssertions(T? value) { }
    }
    public class NullableNumericAssertions<T, TAssertions> : FluentAssertionsAsync.Numeric.NumericAssertions<T, TAssertions>
        where T :  struct, System.IComparable<T>
        where TAssertions : FluentAssertionsAsync.Numeric.NullableNumericAssertions<T, TAssertions>
    {
        public NullableNumericAssertions(T? value) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeNull(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveValue(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Match(System.Linq.Expressions.Expression<System.Func<T?, bool>> predicate, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeNull(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotHaveValue(string because = "", params object[] becauseArgs) { }
    }
    public class NumericAssertions<T> : FluentAssertionsAsync.Numeric.NumericAssertions<T, FluentAssertionsAsync.Numeric.NumericAssertions<T>>
        where T :  struct, System.IComparable<T>
    {
        public NumericAssertions(T value) { }
    }
    public class NumericAssertions<T, TAssertions>
        where T :  struct, System.IComparable<T>
        where TAssertions : FluentAssertionsAsync.Numeric.NumericAssertions<T, TAssertions>
    {
        public NumericAssertions(T value) { }
        public T? Subject { get; }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Be(T expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Be(T? expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeGreaterThan(T expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeGreaterThanOrEqualTo(T expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeInRange(T minimumValue, T maximumValue, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeLessThan(T expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeLessThanOrEqualTo(T expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeNegative(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeOfType(System.Type expectedType, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeOneOf(params T[] validValues) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<T> validValues, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BePositive(string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Match(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBe(T unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBe(T? unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeInRange(T minimumValue, T maximumValue, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeOfType(System.Type unexpectedType, string because = "", params object[] becauseArgs) { }
    }
}
namespace FluentAssertionsAsync.Primitives
{
    public class BooleanAssertions : FluentAssertionsAsync.Primitives.BooleanAssertions<FluentAssertionsAsync.Primitives.BooleanAssertions>
    {
        public BooleanAssertions(bool? value) { }
    }
    public class BooleanAssertions<TAssertions>
        where TAssertions : FluentAssertionsAsync.Primitives.BooleanAssertions<TAssertions>
    {
        public BooleanAssertions(bool? value) { }
        public bool? Subject { get; }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Be(bool expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeFalse(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeTrue(string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Imply(bool consequent, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBe(bool unexpected, string because = "", params object[] becauseArgs) { }
    }
    public class DateTimeAssertions : FluentAssertionsAsync.Primitives.DateTimeAssertions<FluentAssertionsAsync.Primitives.DateTimeAssertions>
    {
        public DateTimeAssertions(System.DateTime? value) { }
    }
    public class DateTimeAssertions<TAssertions>
        where TAssertions : FluentAssertionsAsync.Primitives.DateTimeAssertions<TAssertions>
    {
        public DateTimeAssertions(System.DateTime? value) { }
        public System.DateTime? Subject { get; }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Be(System.DateTime expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Be(System.DateTime? expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeAfter(System.DateTime expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.Primitives.DateTimeRangeAssertions<TAssertions> BeAtLeast(System.TimeSpan timeSpan) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeBefore(System.DateTime expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeCloseTo(System.DateTime nearbyTime, System.TimeSpan precision, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.Primitives.DateTimeRangeAssertions<TAssertions> BeExactly(System.TimeSpan timeSpan) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeIn(System.DateTimeKind expectedKind, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.Primitives.DateTimeRangeAssertions<TAssertions> BeLessThan(System.TimeSpan timeSpan) { }
        public FluentAssertionsAsync.Primitives.DateTimeRangeAssertions<TAssertions> BeMoreThan(System.TimeSpan timeSpan) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeOnOrAfter(System.DateTime expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeOnOrBefore(System.DateTime expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeOneOf(params System.DateTime[] validValues) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeOneOf(params System.Nullable<System.DateTime>[] validValues) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<System.DateTime> validValues, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<System.DateTime?> validValues, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeSameDateAs(System.DateTime expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.Primitives.DateTimeRangeAssertions<TAssertions> BeWithin(System.TimeSpan timeSpan) { }
        public override bool Equals(object obj) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveDay(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveHour(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveMinute(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveMonth(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveSecond(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveYear(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBe(System.DateTime unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBe(System.DateTime? unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeAfter(System.DateTime unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeBefore(System.DateTime unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeCloseTo(System.DateTime distantTime, System.TimeSpan precision, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeOnOrAfter(System.DateTime unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeOnOrBefore(System.DateTime unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeSameDateAs(System.DateTime unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotHaveDay(int unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotHaveHour(int unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotHaveMinute(int unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotHaveMonth(int unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotHaveSecond(int unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotHaveYear(int unexpected, string because = "", params object[] becauseArgs) { }
    }
    public class DateTimeOffsetAssertions : FluentAssertionsAsync.Primitives.DateTimeOffsetAssertions<FluentAssertionsAsync.Primitives.DateTimeOffsetAssertions>
    {
        public DateTimeOffsetAssertions(System.DateTimeOffset? value) { }
    }
    public class DateTimeOffsetAssertions<TAssertions>
        where TAssertions : FluentAssertionsAsync.Primitives.DateTimeOffsetAssertions<TAssertions>
    {
        public DateTimeOffsetAssertions(System.DateTimeOffset? value) { }
        public System.DateTimeOffset? Subject { get; }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Be(System.DateTimeOffset expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Be(System.DateTimeOffset? expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeAfter(System.DateTimeOffset expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.Primitives.DateTimeOffsetRangeAssertions<TAssertions> BeAtLeast(System.TimeSpan timeSpan) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeBefore(System.DateTimeOffset expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeCloseTo(System.DateTimeOffset nearbyTime, System.TimeSpan precision, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.Primitives.DateTimeOffsetRangeAssertions<TAssertions> BeExactly(System.TimeSpan timeSpan) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeExactly(System.DateTimeOffset expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeExactly(System.DateTimeOffset? expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.Primitives.DateTimeOffsetRangeAssertions<TAssertions> BeLessThan(System.TimeSpan timeSpan) { }
        public FluentAssertionsAsync.Primitives.DateTimeOffsetRangeAssertions<TAssertions> BeMoreThan(System.TimeSpan timeSpan) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeOnOrAfter(System.DateTimeOffset expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeOnOrBefore(System.DateTimeOffset expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeOneOf(params System.DateTimeOffset[] validValues) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeOneOf(params System.Nullable<System.DateTimeOffset>[] validValues) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<System.DateTimeOffset> validValues, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<System.DateTimeOffset?> validValues, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeSameDateAs(System.DateTimeOffset expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.Primitives.DateTimeOffsetRangeAssertions<TAssertions> BeWithin(System.TimeSpan timeSpan) { }
        public override bool Equals(object obj) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveDay(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveHour(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveMinute(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveMonth(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveOffset(System.TimeSpan expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveSecond(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveYear(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBe(System.DateTimeOffset unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBe(System.DateTimeOffset? unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeAfter(System.DateTimeOffset unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeBefore(System.DateTimeOffset unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeCloseTo(System.DateTimeOffset distantTime, System.TimeSpan precision, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeExactly(System.DateTimeOffset unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeExactly(System.DateTimeOffset? unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeOnOrAfter(System.DateTimeOffset unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeOnOrBefore(System.DateTimeOffset unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeSameDateAs(System.DateTimeOffset unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotHaveDay(int unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotHaveHour(int unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotHaveMinute(int unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotHaveMonth(int unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotHaveOffset(System.TimeSpan unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotHaveSecond(int unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotHaveYear(int unexpected, string because = "", params object[] becauseArgs) { }
    }
    public class DateTimeOffsetRangeAssertions<TAssertions>
        where TAssertions : FluentAssertionsAsync.Primitives.DateTimeOffsetAssertions<TAssertions>
    {
        protected DateTimeOffsetRangeAssertions(TAssertions parentAssertions, System.DateTimeOffset? subject, FluentAssertionsAsync.Primitives.TimeSpanCondition condition, System.TimeSpan timeSpan) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> After(System.DateTimeOffset target, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Before(System.DateTimeOffset target, string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
    }
    public class DateTimeRangeAssertions<TAssertions>
        where TAssertions : FluentAssertionsAsync.Primitives.DateTimeAssertions<TAssertions>
    {
        protected DateTimeRangeAssertions(TAssertions parentAssertions, System.DateTime? subject, FluentAssertionsAsync.Primitives.TimeSpanCondition condition, System.TimeSpan timeSpan) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> After(System.DateTime target, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Before(System.DateTime target, string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
    }
    public class EnumAssertions<TEnum> : FluentAssertionsAsync.Primitives.EnumAssertions<TEnum, FluentAssertionsAsync.Primitives.EnumAssertions<TEnum>>
        where TEnum :  struct, System.Enum
    {
        public EnumAssertions(TEnum subject) { }
    }
    public class EnumAssertions<TEnum, TAssertions>
        where TEnum :  struct, System.Enum
        where TAssertions : FluentAssertionsAsync.Primitives.EnumAssertions<TEnum, TAssertions>
    {
        public EnumAssertions(TEnum subject) { }
        public TEnum? Subject { get; }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Be(TEnum expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Be(TEnum? expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeDefined(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeOneOf(params TEnum[] validValues) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<TEnum> validValues, string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveFlag(TEnum expectedFlag, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveSameNameAs<T>(T expected, string because = "", params object[] becauseArgs)
            where T :  struct, System.Enum { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveSameValueAs<T>(T expected, string because = "", params object[] becauseArgs)
            where T :  struct, System.Enum { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveValue(decimal expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Match(System.Linq.Expressions.Expression<System.Func<TEnum?, bool>> predicate, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBe(TEnum unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBe(TEnum? unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeDefined(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotHaveFlag(TEnum unexpectedFlag, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotHaveSameNameAs<T>(T unexpected, string because = "", params object[] becauseArgs)
            where T :  struct, System.Enum { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotHaveSameValueAs<T>(T unexpected, string because = "", params object[] becauseArgs)
            where T :  struct, System.Enum { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotHaveValue(decimal unexpected, string because = "", params object[] becauseArgs) { }
    }
    public class GuidAssertions : FluentAssertionsAsync.Primitives.GuidAssertions<FluentAssertionsAsync.Primitives.GuidAssertions>
    {
        public GuidAssertions(System.Guid? value) { }
    }
    public class GuidAssertions<TAssertions>
        where TAssertions : FluentAssertionsAsync.Primitives.GuidAssertions<TAssertions>
    {
        public GuidAssertions(System.Guid? value) { }
        public System.Guid? Subject { get; }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Be(System.Guid expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Be(string expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeEmpty(string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBe(System.Guid unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBe(string unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeEmpty(string because = "", params object[] becauseArgs) { }
    }
    public class HttpResponseMessageAssertions : FluentAssertionsAsync.Primitives.HttpResponseMessageAssertions<FluentAssertionsAsync.Primitives.HttpResponseMessageAssertions>
    {
        public HttpResponseMessageAssertions(System.Net.Http.HttpResponseMessage value) { }
    }
    public class HttpResponseMessageAssertions<TAssertions> : FluentAssertionsAsync.Primitives.ObjectAssertions<System.Net.Http.HttpResponseMessage, TAssertions>
        where TAssertions : FluentAssertionsAsync.Primitives.HttpResponseMessageAssertions<TAssertions>
    {
        protected HttpResponseMessageAssertions(System.Net.Http.HttpResponseMessage value) { }
        protected override string Identifier { get; }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeRedirection(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeSuccessful(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveClientError(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveError(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveServerError(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveStatusCode(System.Net.HttpStatusCode expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotHaveStatusCode(System.Net.HttpStatusCode unexpected, string because = "", params object[] becauseArgs) { }
    }
    public class NullableBooleanAssertions : FluentAssertionsAsync.Primitives.NullableBooleanAssertions<FluentAssertionsAsync.Primitives.NullableBooleanAssertions>
    {
        public NullableBooleanAssertions(bool? value) { }
    }
    public class NullableBooleanAssertions<TAssertions> : FluentAssertionsAsync.Primitives.BooleanAssertions<TAssertions>
        where TAssertions : FluentAssertionsAsync.Primitives.NullableBooleanAssertions<TAssertions>
    {
        public NullableBooleanAssertions(bool? value) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Be(bool? expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeNull(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveValue(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBe(bool? unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeFalse(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeNull(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeTrue(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotHaveValue(string because = "", params object[] becauseArgs) { }
    }
    public class NullableDateTimeAssertions : FluentAssertionsAsync.Primitives.NullableDateTimeAssertions<FluentAssertionsAsync.Primitives.NullableDateTimeAssertions>
    {
        public NullableDateTimeAssertions(System.DateTime? expected) { }
    }
    public class NullableDateTimeAssertions<TAssertions> : FluentAssertionsAsync.Primitives.DateTimeAssertions<TAssertions>
        where TAssertions : FluentAssertionsAsync.Primitives.NullableDateTimeAssertions<TAssertions>
    {
        public NullableDateTimeAssertions(System.DateTime? expected) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeNull(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveValue(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeNull(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotHaveValue(string because = "", params object[] becauseArgs) { }
    }
    public class NullableDateTimeOffsetAssertions : FluentAssertionsAsync.Primitives.NullableDateTimeOffsetAssertions<FluentAssertionsAsync.Primitives.NullableDateTimeOffsetAssertions>
    {
        public NullableDateTimeOffsetAssertions(System.DateTimeOffset? expected) { }
    }
    public class NullableDateTimeOffsetAssertions<TAssertions> : FluentAssertionsAsync.Primitives.DateTimeOffsetAssertions<TAssertions>
        where TAssertions : FluentAssertionsAsync.Primitives.NullableDateTimeOffsetAssertions<TAssertions>
    {
        public NullableDateTimeOffsetAssertions(System.DateTimeOffset? expected) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeNull(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveValue(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeNull(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotHaveValue(string because = "", params object[] becauseArgs) { }
    }
    public class NullableEnumAssertions<TEnum> : FluentAssertionsAsync.Primitives.NullableEnumAssertions<TEnum, FluentAssertionsAsync.Primitives.NullableEnumAssertions<TEnum>>
        where TEnum :  struct, System.Enum
    {
        public NullableEnumAssertions(TEnum? subject) { }
    }
    public class NullableEnumAssertions<TEnum, TAssertions> : FluentAssertionsAsync.Primitives.EnumAssertions<TEnum, TAssertions>
        where TEnum :  struct, System.Enum
        where TAssertions : FluentAssertionsAsync.Primitives.NullableEnumAssertions<TEnum, TAssertions>
    {
        public NullableEnumAssertions(TEnum? subject) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeNull(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<TAssertions, TEnum> HaveValue(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<TAssertions, TEnum> NotBeNull(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotHaveValue(string because = "", params object[] becauseArgs) { }
    }
    public class NullableGuidAssertions : FluentAssertionsAsync.Primitives.NullableGuidAssertions<FluentAssertionsAsync.Primitives.NullableGuidAssertions>
    {
        public NullableGuidAssertions(System.Guid? value) { }
    }
    public class NullableGuidAssertions<TAssertions> : FluentAssertionsAsync.Primitives.GuidAssertions<TAssertions>
        where TAssertions : FluentAssertionsAsync.Primitives.NullableGuidAssertions<TAssertions>
    {
        public NullableGuidAssertions(System.Guid? value) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Be(System.Guid? expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeNull(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveValue(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeNull(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotHaveValue(string because = "", params object[] becauseArgs) { }
    }
    public class NullableSimpleTimeSpanAssertions : FluentAssertionsAsync.Primitives.NullableSimpleTimeSpanAssertions<FluentAssertionsAsync.Primitives.NullableSimpleTimeSpanAssertions>
    {
        public NullableSimpleTimeSpanAssertions(System.TimeSpan? value) { }
    }
    public class NullableSimpleTimeSpanAssertions<TAssertions> : FluentAssertionsAsync.Primitives.SimpleTimeSpanAssertions<TAssertions>
        where TAssertions : FluentAssertionsAsync.Primitives.NullableSimpleTimeSpanAssertions<TAssertions>
    {
        public NullableSimpleTimeSpanAssertions(System.TimeSpan? value) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Be(System.TimeSpan? expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeNull(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveValue(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeNull(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotHaveValue(string because = "", params object[] becauseArgs) { }
    }
    public class ObjectAssertions : FluentAssertionsAsync.Primitives.ObjectAssertions<object, FluentAssertionsAsync.Primitives.ObjectAssertions>
    {
        public ObjectAssertions(object value) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Primitives.ObjectAssertions> Be<TExpectation>(TExpectation expected, System.Collections.Generic.IEqualityComparer<TExpectation> comparer, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Primitives.ObjectAssertions> BeOneOf<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> validValues, System.Collections.Generic.IEqualityComparer<TExpectation> comparer, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Primitives.ObjectAssertions> NotBe<TExpectation>(TExpectation unexpected, System.Collections.Generic.IEqualityComparer<TExpectation> comparer, string because = "", params object[] becauseArgs) { }
    }
    public class ObjectAssertions<TSubject, TAssertions> : FluentAssertionsAsync.Primitives.ReferenceTypeAssertions<TSubject, TAssertions>
        where TAssertions : FluentAssertionsAsync.Primitives.ObjectAssertions<TSubject, TAssertions>
    {
        public ObjectAssertions(TSubject value) { }
        protected override string Identifier { get; }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Be(TSubject expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Be(TSubject expected, System.Collections.Generic.IEqualityComparer<TSubject> comparer, string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndConstraint<TAssertions>> BeEquivalentToAsync<TExpectation>(TExpectation expectation, string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndConstraint<TAssertions>> BeEquivalentToAsync<TExpectation>(TExpectation expectation, System.Func<FluentAssertionsAsync.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertionsAsync.Equivalency.EquivalencyOptions<TExpectation>> config, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeOneOf(params TSubject[] validValues) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<TSubject> validValues, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<TSubject> validValues, System.Collections.Generic.IEqualityComparer<TSubject> comparer, string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBe(TSubject unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBe(TSubject unexpected, System.Collections.Generic.IEqualityComparer<TSubject> comparer, string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndConstraint<TAssertions>> NotBeEquivalentToAsync<TExpectation>(TExpectation unexpected, string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndConstraint<TAssertions>> NotBeEquivalentToAsync<TExpectation>(TExpectation unexpected, System.Func<FluentAssertionsAsync.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertionsAsync.Equivalency.EquivalencyOptions<TExpectation>> config, string because = "", params object[] becauseArgs) { }
    }
    public abstract class ReferenceTypeAssertions<TSubject, TAssertions>
        where TAssertions : FluentAssertionsAsync.Primitives.ReferenceTypeAssertions<TSubject, TAssertions>
    {
        protected ReferenceTypeAssertions(TSubject subject) { }
        protected abstract string Identifier { get; }
        public TSubject Subject { get; }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeAssignableTo(System.Type type, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<TAssertions, T> BeAssignableTo<T>(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeNull(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeOfType(System.Type expectedType, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<TAssertions, T> BeOfType<T>(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeSameAs(TSubject expected, string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Match(System.Linq.Expressions.Expression<System.Func<TSubject, bool>> predicate, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Match<T>(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, string because = "", params object[] becauseArgs)
            where T : TSubject { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeAssignableTo(System.Type type, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeAssignableTo<T>(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeNull(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeOfType(System.Type unexpectedType, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeOfType<T>(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeSameAs(TSubject unexpected, string because = "", params object[] becauseArgs) { }
    }
    public class SimpleTimeSpanAssertions : FluentAssertionsAsync.Primitives.SimpleTimeSpanAssertions<FluentAssertionsAsync.Primitives.SimpleTimeSpanAssertions>
    {
        public SimpleTimeSpanAssertions(System.TimeSpan? value) { }
    }
    public class SimpleTimeSpanAssertions<TAssertions>
        where TAssertions : FluentAssertionsAsync.Primitives.SimpleTimeSpanAssertions<TAssertions>
    {
        public SimpleTimeSpanAssertions(System.TimeSpan? value) { }
        public System.TimeSpan? Subject { get; }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Be(System.TimeSpan expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeCloseTo(System.TimeSpan nearbyTime, System.TimeSpan precision, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeGreaterThan(System.TimeSpan expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeGreaterThanOrEqualTo(System.TimeSpan expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeLessThan(System.TimeSpan expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeLessThanOrEqualTo(System.TimeSpan expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeNegative(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BePositive(string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBe(System.TimeSpan unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeCloseTo(System.TimeSpan distantTime, System.TimeSpan precision, string because = "", params object[] becauseArgs) { }
    }
    public class StringAssertions : FluentAssertionsAsync.Primitives.StringAssertions<FluentAssertionsAsync.Primitives.StringAssertions>
    {
        public StringAssertions(string value) { }
    }
    public class StringAssertions<TAssertions> : FluentAssertionsAsync.Primitives.ReferenceTypeAssertions<string, TAssertions>
        where TAssertions : FluentAssertionsAsync.Primitives.StringAssertions<TAssertions>
    {
        public StringAssertions(string value) { }
        protected override string Identifier { get; }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Be(string expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeEmpty(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeEquivalentTo(string expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeLowerCased(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeNullOrEmpty(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeNullOrWhiteSpace(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeOneOf(params string[] validValues) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<string> validValues, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeUpperCased(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Contain(string expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Contain(string expected, FluentAssertionsAsync.OccurrenceConstraint occurrenceConstraint, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> ContainAll(params string[] values) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> ContainAll(System.Collections.Generic.IEnumerable<string> values, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> ContainAny(params string[] values) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> ContainAny(System.Collections.Generic.IEnumerable<string> values, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> ContainEquivalentOf(string expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> ContainEquivalentOf(string expected, FluentAssertionsAsync.OccurrenceConstraint occurrenceConstraint, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> EndWith(string expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> EndWithEquivalentOf(string expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveLength(int expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> Match(string wildcardPattern, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> MatchEquivalentOf(string wildcardPattern, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> MatchRegex(string regularExpression, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> MatchRegex(System.Text.RegularExpressions.Regex regularExpression, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> MatchRegex(string regularExpression, FluentAssertionsAsync.OccurrenceConstraint occurrenceConstraint, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> MatchRegex(System.Text.RegularExpressions.Regex regularExpression, FluentAssertionsAsync.OccurrenceConstraint occurrenceConstraint, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBe(string unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeEmpty(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeEquivalentTo(string unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeLowerCased(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeNullOrEmpty(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeNullOrWhiteSpace(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeUpperCased(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotContain(string unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotContainAll(params string[] values) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotContainAll(System.Collections.Generic.IEnumerable<string> values, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotContainAny(params string[] values) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotContainAny(System.Collections.Generic.IEnumerable<string> values, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotContainEquivalentOf(string unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotEndWith(string unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotEndWithEquivalentOf(string unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotMatch(string wildcardPattern, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotMatchEquivalentOf(string wildcardPattern, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotMatchRegex(string regularExpression, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotMatchRegex(System.Text.RegularExpressions.Regex regularExpression, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotStartWith(string unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotStartWithEquivalentOf(string unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> StartWith(string expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> StartWithEquivalentOf(string expected, string because = "", params object[] becauseArgs) { }
    }
    public enum TimeSpanCondition
    {
        MoreThan = 0,
        AtLeast = 1,
        Exactly = 2,
        Within = 3,
        LessThan = 4,
    }
}
namespace FluentAssertionsAsync.Specialized
{
    public class ActionAssertions : FluentAssertionsAsync.Specialized.DelegateAssertions<System.Action, FluentAssertionsAsync.Specialized.ActionAssertions>
    {
        public ActionAssertions(System.Action subject, FluentAssertionsAsync.Specialized.IExtractExceptions extractor) { }
        public ActionAssertions(System.Action subject, FluentAssertionsAsync.Specialized.IExtractExceptions extractor, FluentAssertionsAsync.Common.IClock clock) { }
        protected override string Identifier { get; }
        protected override void InvokeSubject() { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Specialized.ActionAssertions> NotThrow(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Specialized.ActionAssertions> NotThrowAfter(System.TimeSpan waitTime, System.TimeSpan pollInterval, string because = "", params object[] becauseArgs) { }
    }
    public class AsyncFunctionAssertions<TTask, TAssertions> : FluentAssertionsAsync.Specialized.DelegateAssertionsBase<System.Func<TTask>, TAssertions>
        where TTask : System.Threading.Tasks.Task
        where TAssertions : FluentAssertionsAsync.Specialized.AsyncFunctionAssertions<TTask, TAssertions>
    {
        protected AsyncFunctionAssertions(System.Func<TTask> subject, FluentAssertionsAsync.Specialized.IExtractExceptions extractor, FluentAssertionsAsync.Common.IClock clock) { }
        protected override string Identifier { get; }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndConstraint<TAssertions>> NotCompleteWithinAsync(System.TimeSpan timeSpan, string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndConstraint<TAssertions>> NotThrowAsync<TException>(string because = "", params object[] becauseArgs)
            where TException : System.Exception { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.Specialized.ExceptionAssertions<TException>> ThrowAsync<TException>(string because = "", params object[] becauseArgs)
            where TException : System.Exception { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.Specialized.ExceptionAssertions<TException>> ThrowExactlyAsync<TException>(string because = "", params object[] becauseArgs)
            where TException : System.Exception { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.Specialized.ExceptionAssertions<TException>> ThrowWithinAsync<TException>(System.TimeSpan timeSpan, string because = "", params object[] becauseArgs)
            where TException : System.Exception { }
    }
    public abstract class DelegateAssertionsBase<TDelegate, TAssertions> : FluentAssertionsAsync.Primitives.ReferenceTypeAssertions<TDelegate, FluentAssertionsAsync.Specialized.DelegateAssertionsBase<TDelegate, TAssertions>>
        where TDelegate : System.Delegate
        where TAssertions : FluentAssertionsAsync.Specialized.DelegateAssertionsBase<TDelegate, TAssertions>
    {
        protected FluentAssertionsAsync.AndConstraint<TAssertions> NotThrowInternal(System.Exception exception, string because, object[] becauseArgs) { }
        protected FluentAssertionsAsync.AndConstraint<TAssertions> NotThrowInternal<TException>(System.Exception exception, string because, object[] becauseArgs)
            where TException : System.Exception { }
        protected FluentAssertionsAsync.Specialized.ExceptionAssertions<TException> ThrowInternal<TException>(System.Exception exception, string because, object[] becauseArgs)
            where TException : System.Exception { }
    }
    public abstract class DelegateAssertions<TDelegate, TAssertions> : FluentAssertionsAsync.Specialized.DelegateAssertionsBase<TDelegate, TAssertions>
        where TDelegate : System.Delegate
        where TAssertions : FluentAssertionsAsync.Specialized.DelegateAssertions<TDelegate, TAssertions>
    {
        protected DelegateAssertions(TDelegate @delegate, FluentAssertionsAsync.Specialized.IExtractExceptions extractor) { }
        protected abstract void InvokeSubject();
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotThrow<TException>(string because = "", params object[] becauseArgs)
            where TException : System.Exception { }
        public FluentAssertionsAsync.Specialized.ExceptionAssertions<TException> Throw<TException>(string because = "", params object[] becauseArgs)
            where TException : System.Exception { }
        public FluentAssertionsAsync.Specialized.ExceptionAssertions<TException> ThrowExactly<TException>(string because = "", params object[] becauseArgs)
            where TException : System.Exception { }
    }
    public class ExceptionAssertions<TException> : FluentAssertionsAsync.Primitives.ReferenceTypeAssertions<System.Collections.Generic.IEnumerable<TException>, FluentAssertionsAsync.Specialized.ExceptionAssertions<TException>>
        where TException : System.Exception
    {
        public ExceptionAssertions(System.Collections.Generic.IEnumerable<TException> exceptions) { }
        public TException And { get; }
        protected override string Identifier { get; }
        public TException Which { get; }
        public FluentAssertionsAsync.Specialized.ExceptionAssertions<TException> Where(System.Linq.Expressions.Expression<System.Func<TException, bool>> exceptionExpression, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.Specialized.ExceptionAssertions<System.Exception> WithInnerException(System.Type innerException, string because = "", params object[] becauseArgs) { }
        public virtual FluentAssertionsAsync.Specialized.ExceptionAssertions<TInnerException> WithInnerException<TInnerException>(string because = "", params object[] becauseArgs)
            where TInnerException : System.Exception { }
        public FluentAssertionsAsync.Specialized.ExceptionAssertions<System.Exception> WithInnerExceptionExactly(System.Type innerException, string because = "", params object[] becauseArgs) { }
        public virtual FluentAssertionsAsync.Specialized.ExceptionAssertions<TInnerException> WithInnerExceptionExactly<TInnerException>(string because = "", params object[] becauseArgs)
            where TInnerException : System.Exception { }
        public virtual FluentAssertionsAsync.Specialized.ExceptionAssertions<TException> WithMessage(string expectedWildcardPattern, string because = "", params object[] becauseArgs) { }
    }
    public class ExecutionTime
    {
        public ExecutionTime(System.Action action, FluentAssertionsAsync.Common.StartTimer createTimer) { }
        public ExecutionTime(System.Func<System.Threading.Tasks.Task> action, FluentAssertionsAsync.Common.StartTimer createTimer) { }
        protected ExecutionTime(System.Action action, string actionDescription, FluentAssertionsAsync.Common.StartTimer createTimer) { }
        protected ExecutionTime(System.Func<System.Threading.Tasks.Task> action, string actionDescription, FluentAssertionsAsync.Common.StartTimer createTimer) { }
    }
    public class ExecutionTimeAssertions
    {
        public ExecutionTimeAssertions(FluentAssertionsAsync.Specialized.ExecutionTime executionTime) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Specialized.ExecutionTimeAssertions> BeCloseTo(System.TimeSpan expectedDuration, System.TimeSpan precision, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Specialized.ExecutionTimeAssertions> BeGreaterThan(System.TimeSpan minDuration, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Specialized.ExecutionTimeAssertions> BeGreaterThanOrEqualTo(System.TimeSpan minDuration, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Specialized.ExecutionTimeAssertions> BeLessThan(System.TimeSpan maxDuration, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Specialized.ExecutionTimeAssertions> BeLessThanOrEqualTo(System.TimeSpan maxDuration, string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
    }
    public class FunctionAssertions<T> : FluentAssertionsAsync.Specialized.DelegateAssertions<System.Func<T>, FluentAssertionsAsync.Specialized.FunctionAssertions<T>>
    {
        public FunctionAssertions(System.Func<T> subject, FluentAssertionsAsync.Specialized.IExtractExceptions extractor) { }
        public FunctionAssertions(System.Func<T> subject, FluentAssertionsAsync.Specialized.IExtractExceptions extractor, FluentAssertionsAsync.Common.IClock clock) { }
        protected override string Identifier { get; }
        protected override void InvokeSubject() { }
        public FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Specialized.FunctionAssertions<T>, T> NotThrow(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Specialized.FunctionAssertions<T>, T> NotThrowAfter(System.TimeSpan waitTime, System.TimeSpan pollInterval, string because = "", params object[] becauseArgs) { }
    }
    public class GenericAsyncFunctionAssertions<TResult> : FluentAssertionsAsync.Specialized.AsyncFunctionAssertions<System.Threading.Tasks.Task<TResult>, FluentAssertionsAsync.Specialized.GenericAsyncFunctionAssertions<TResult>>
    {
        public GenericAsyncFunctionAssertions(System.Func<System.Threading.Tasks.Task<TResult>> subject, FluentAssertionsAsync.Specialized.IExtractExceptions extractor) { }
        public GenericAsyncFunctionAssertions(System.Func<System.Threading.Tasks.Task<TResult>> subject, FluentAssertionsAsync.Specialized.IExtractExceptions extractor, FluentAssertionsAsync.Common.IClock clock) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Specialized.GenericAsyncFunctionAssertions<TResult>, TResult>> CompleteWithinAsync(System.TimeSpan timeSpan, string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Specialized.GenericAsyncFunctionAssertions<TResult>, TResult>> NotThrowAfterAsync(System.TimeSpan waitTime, System.TimeSpan pollInterval, string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Specialized.GenericAsyncFunctionAssertions<TResult>, TResult>> NotThrowAsync(string because = "", params object[] becauseArgs) { }
    }
    public interface IExtractExceptions
    {
        System.Collections.Generic.IEnumerable<T> OfType<T>(System.Exception actualException)
            where T : System.Exception;
    }
    public class MemberExecutionTime<T> : FluentAssertionsAsync.Specialized.ExecutionTime
    {
        public MemberExecutionTime(T subject, System.Linq.Expressions.Expression<System.Action<T>> action, FluentAssertionsAsync.Common.StartTimer createTimer) { }
    }
    public class NonGenericAsyncFunctionAssertions : FluentAssertionsAsync.Specialized.AsyncFunctionAssertions<System.Threading.Tasks.Task, FluentAssertionsAsync.Specialized.NonGenericAsyncFunctionAssertions>
    {
        public NonGenericAsyncFunctionAssertions(System.Func<System.Threading.Tasks.Task> subject, FluentAssertionsAsync.Specialized.IExtractExceptions extractor) { }
        public NonGenericAsyncFunctionAssertions(System.Func<System.Threading.Tasks.Task> subject, FluentAssertionsAsync.Specialized.IExtractExceptions extractor, FluentAssertionsAsync.Common.IClock clock) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Specialized.NonGenericAsyncFunctionAssertions>> CompleteWithinAsync(System.TimeSpan timeSpan, string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Specialized.NonGenericAsyncFunctionAssertions>> NotThrowAfterAsync(System.TimeSpan waitTime, System.TimeSpan pollInterval, string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Specialized.NonGenericAsyncFunctionAssertions>> NotThrowAsync(string because = "", params object[] becauseArgs) { }
    }
    public class TaskCompletionSourceAssertionsBase
    {
        protected TaskCompletionSourceAssertionsBase(FluentAssertionsAsync.Common.IClock clock) { }
        public override bool Equals(object obj) { }
    }
    public class TaskCompletionSourceAssertions<T> : FluentAssertionsAsync.Specialized.TaskCompletionSourceAssertionsBase
    {
        public TaskCompletionSourceAssertions(System.Threading.Tasks.TaskCompletionSource<T> tcs) { }
        public TaskCompletionSourceAssertions(System.Threading.Tasks.TaskCompletionSource<T> tcs, FluentAssertionsAsync.Common.IClock clock) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Specialized.TaskCompletionSourceAssertions<T>, T>> CompleteWithinAsync(System.TimeSpan timeSpan, string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Specialized.TaskCompletionSourceAssertions<T>>> NotCompleteWithinAsync(System.TimeSpan timeSpan, string because = "", params object[] becauseArgs) { }
    }
}
namespace FluentAssertionsAsync.Streams
{
    public class BufferedStreamAssertions : FluentAssertionsAsync.Streams.BufferedStreamAssertions<FluentAssertionsAsync.Streams.BufferedStreamAssertions>
    {
        public BufferedStreamAssertions(System.IO.BufferedStream stream) { }
    }
    public class BufferedStreamAssertions<TAssertions> : FluentAssertionsAsync.Streams.StreamAssertions<System.IO.BufferedStream, TAssertions>
        where TAssertions : FluentAssertionsAsync.Streams.BufferedStreamAssertions<TAssertions>
    {
        public BufferedStreamAssertions(System.IO.BufferedStream stream) { }
        protected override string Identifier { get; }
    }
    public class StreamAssertions : FluentAssertionsAsync.Streams.StreamAssertions<System.IO.Stream, FluentAssertionsAsync.Streams.StreamAssertions>
    {
        public StreamAssertions(System.IO.Stream stream) { }
    }
    public class StreamAssertions<TSubject, TAssertions> : FluentAssertionsAsync.Primitives.ReferenceTypeAssertions<TSubject, TAssertions>
        where TSubject : System.IO.Stream
        where TAssertions : FluentAssertionsAsync.Streams.StreamAssertions<TSubject, TAssertions>
    {
        public StreamAssertions(TSubject stream) { }
        protected override string Identifier { get; }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeReadOnly(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeReadable(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeSeekable(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeWritable(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeWriteOnly(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveLength(long expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HavePosition(long expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeReadOnly(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeReadable(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeSeekable(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeWritable(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeWriteOnly(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotHaveLength(long unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotHavePosition(long unexpected, string because = "", params object[] becauseArgs) { }
    }
}
namespace FluentAssertionsAsync.Types
{
    public static class AllTypes
    {
        public static FluentAssertionsAsync.Types.TypeSelector From(System.Reflection.Assembly assembly) { }
    }
    public class AssemblyAssertions : FluentAssertionsAsync.Primitives.ReferenceTypeAssertions<System.Reflection.Assembly, FluentAssertionsAsync.Types.AssemblyAssertions>
    {
        public AssemblyAssertions(System.Reflection.Assembly assembly) { }
        protected override string Identifier { get; }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.AssemblyAssertions> BeSignedWithPublicKey(string publicKey, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.AssemblyAssertions> BeUnsigned(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Types.AssemblyAssertions, System.Type> DefineType(string @namespace, string name, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.AssemblyAssertions> NotReference(System.Reflection.Assembly assembly, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.AssemblyAssertions> Reference(System.Reflection.Assembly assembly, string because = "", params object[] becauseArgs) { }
    }
    public class ConstructorInfoAssertions : FluentAssertionsAsync.Types.MethodBaseAssertions<System.Reflection.ConstructorInfo, FluentAssertionsAsync.Types.ConstructorInfoAssertions>
    {
        public ConstructorInfoAssertions(System.Reflection.ConstructorInfo constructorInfo) { }
        protected override string Identifier { get; }
    }
    public abstract class MemberInfoAssertions<TSubject, TAssertions> : FluentAssertionsAsync.Primitives.ReferenceTypeAssertions<TSubject, TAssertions>
        where TSubject : System.Reflection.MemberInfo
        where TAssertions : FluentAssertionsAsync.Types.MemberInfoAssertions<TSubject, TAssertions>
    {
        protected MemberInfoAssertions(TSubject subject) { }
        protected override string Identifier { get; }
        public FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Types.MemberInfoAssertions<TSubject, TAssertions>, TAttribute> BeDecoratedWith<TAttribute>(string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Types.MemberInfoAssertions<TSubject, TAssertions>, TAttribute> BeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeDecoratedWith<TAttribute>(string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
    }
    public abstract class MethodBaseAssertions<TSubject, TAssertions> : FluentAssertionsAsync.Types.MemberInfoAssertions<TSubject, TAssertions>
        where TSubject : System.Reflection.MethodBase
        where TAssertions : FluentAssertionsAsync.Types.MethodBaseAssertions<TSubject, TAssertions>
    {
        protected MethodBaseAssertions(TSubject subject) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> HaveAccessModifier(FluentAssertionsAsync.Common.CSharpAccessModifier accessModifier, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotHaveAccessModifier(FluentAssertionsAsync.Common.CSharpAccessModifier accessModifier, string because = "", params object[] becauseArgs) { }
    }
    public class MethodInfoAssertions : FluentAssertionsAsync.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertionsAsync.Types.MethodInfoAssertions>
    {
        public MethodInfoAssertions(System.Reflection.MethodInfo methodInfo) { }
        protected override string Identifier { get; }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.MethodInfoAssertions> BeAsync(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.MethodInfoAssertions> BeVirtual(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.MethodInfoAssertions> NotBeAsync(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.MethodInfoAssertions> NotBeVirtual(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertionsAsync.Types.MethodInfoAssertions>> NotReturn(System.Type returnType, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertionsAsync.Types.MethodInfoAssertions>> NotReturn<TReturn>(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertionsAsync.Types.MethodInfoAssertions>> NotReturnVoid(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertionsAsync.Types.MethodInfoAssertions>> Return(System.Type returnType, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertionsAsync.Types.MethodInfoAssertions>> Return<TReturn>(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertionsAsync.Types.MethodInfoAssertions>> ReturnVoid(string because = "", params object[] becauseArgs) { }
    }
    public class MethodInfoSelector : System.Collections.Generic.IEnumerable<System.Reflection.MethodInfo>, System.Collections.IEnumerable
    {
        public MethodInfoSelector(System.Collections.Generic.IEnumerable<System.Type> types) { }
        public MethodInfoSelector(System.Type type) { }
        public FluentAssertionsAsync.Types.MethodInfoSelector ThatArePublicOrInternal { get; }
        public FluentAssertionsAsync.Types.MethodInfoSelector ThatDoNotReturnVoid { get; }
        public FluentAssertionsAsync.Types.MethodInfoSelector ThatReturnVoid { get; }
        public System.Collections.Generic.IEnumerator<System.Reflection.MethodInfo> GetEnumerator() { }
        public FluentAssertionsAsync.Types.TypeSelector ReturnTypes() { }
        public FluentAssertionsAsync.Types.MethodInfoSelector ThatAreAbstract() { }
        public FluentAssertionsAsync.Types.MethodInfoSelector ThatAreAsync() { }
        public FluentAssertionsAsync.Types.MethodInfoSelector ThatAreDecoratedWith<TAttribute>()
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.Types.MethodInfoSelector ThatAreDecoratedWithOrInherit<TAttribute>()
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.Types.MethodInfoSelector ThatAreNotAbstract() { }
        public FluentAssertionsAsync.Types.MethodInfoSelector ThatAreNotAsync() { }
        public FluentAssertionsAsync.Types.MethodInfoSelector ThatAreNotDecoratedWith<TAttribute>()
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.Types.MethodInfoSelector ThatAreNotDecoratedWithOrInherit<TAttribute>()
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.Types.MethodInfoSelector ThatAreNotStatic() { }
        public FluentAssertionsAsync.Types.MethodInfoSelector ThatAreNotVirtual() { }
        public FluentAssertionsAsync.Types.MethodInfoSelector ThatAreStatic() { }
        public FluentAssertionsAsync.Types.MethodInfoSelector ThatAreVirtual() { }
        public FluentAssertionsAsync.Types.MethodInfoSelector ThatDoNotReturn<TReturn>() { }
        public FluentAssertionsAsync.Types.MethodInfoSelector ThatReturn<TReturn>() { }
        public System.Reflection.MethodInfo[] ToArray() { }
    }
    public class MethodInfoSelectorAssertions
    {
        public MethodInfoSelectorAssertions(params System.Reflection.MethodInfo[] methods) { }
        protected string Context { get; }
        public System.Collections.Generic.IEnumerable<System.Reflection.MethodInfo> SubjectMethods { get; }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.MethodInfoSelectorAssertions> Be(FluentAssertionsAsync.Common.CSharpAccessModifier accessModifier, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.MethodInfoSelectorAssertions> BeAsync(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.MethodInfoSelectorAssertions> BeDecoratedWith<TAttribute>(string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.MethodInfoSelectorAssertions> BeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.MethodInfoSelectorAssertions> BeVirtual(string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.MethodInfoSelectorAssertions> NotBe(FluentAssertionsAsync.Common.CSharpAccessModifier accessModifier, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.MethodInfoSelectorAssertions> NotBeAsync(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.MethodInfoSelectorAssertions> NotBeDecoratedWith<TAttribute>(string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.MethodInfoSelectorAssertions> NotBeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.MethodInfoSelectorAssertions> NotBeVirtual(string because = "", params object[] becauseArgs) { }
    }
    public class PropertyInfoAssertions : FluentAssertionsAsync.Types.MemberInfoAssertions<System.Reflection.PropertyInfo, FluentAssertionsAsync.Types.PropertyInfoAssertions>
    {
        public PropertyInfoAssertions(System.Reflection.PropertyInfo propertyInfo) { }
        protected override string Identifier { get; }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.PropertyInfoAssertions> BeReadable(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.PropertyInfoAssertions> BeReadable(FluentAssertionsAsync.Common.CSharpAccessModifier accessModifier, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.PropertyInfoAssertions> BeVirtual(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.PropertyInfoAssertions> BeWritable(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.PropertyInfoAssertions> BeWritable(FluentAssertionsAsync.Common.CSharpAccessModifier accessModifier, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.PropertyInfoAssertions> NotBeReadable(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.PropertyInfoAssertions> NotBeVirtual(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.PropertyInfoAssertions> NotBeWritable(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.PropertyInfoAssertions> NotReturn(System.Type propertyType, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.PropertyInfoAssertions> NotReturn<TReturn>(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.PropertyInfoAssertions> Return(System.Type propertyType, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.PropertyInfoAssertions> Return<TReturn>(string because = "", params object[] becauseArgs) { }
    }
    public class PropertyInfoSelector : System.Collections.Generic.IEnumerable<System.Reflection.PropertyInfo>, System.Collections.IEnumerable
    {
        public PropertyInfoSelector(System.Collections.Generic.IEnumerable<System.Type> types) { }
        public PropertyInfoSelector(System.Type type) { }
        public FluentAssertionsAsync.Types.PropertyInfoSelector ThatAreAbstract { get; }
        public FluentAssertionsAsync.Types.PropertyInfoSelector ThatAreNotAbstract { get; }
        public FluentAssertionsAsync.Types.PropertyInfoSelector ThatAreNotStatic { get; }
        public FluentAssertionsAsync.Types.PropertyInfoSelector ThatAreNotVirtual { get; }
        public FluentAssertionsAsync.Types.PropertyInfoSelector ThatArePublicOrInternal { get; }
        public FluentAssertionsAsync.Types.PropertyInfoSelector ThatAreStatic { get; }
        public FluentAssertionsAsync.Types.PropertyInfoSelector ThatAreVirtual { get; }
        public System.Collections.Generic.IEnumerator<System.Reflection.PropertyInfo> GetEnumerator() { }
        public FluentAssertionsAsync.Types.PropertyInfoSelector NotOfType<TReturn>() { }
        public FluentAssertionsAsync.Types.PropertyInfoSelector OfType<TReturn>() { }
        public FluentAssertionsAsync.Types.TypeSelector ReturnTypes() { }
        public FluentAssertionsAsync.Types.PropertyInfoSelector ThatAreDecoratedWith<TAttribute>()
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.Types.PropertyInfoSelector ThatAreDecoratedWithOrInherit<TAttribute>()
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.Types.PropertyInfoSelector ThatAreNotDecoratedWith<TAttribute>()
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.Types.PropertyInfoSelector ThatAreNotDecoratedWithOrInherit<TAttribute>()
            where TAttribute : System.Attribute { }
        public System.Reflection.PropertyInfo[] ToArray() { }
    }
    public class PropertyInfoSelectorAssertions
    {
        public PropertyInfoSelectorAssertions(params System.Reflection.PropertyInfo[] properties) { }
        protected string Context { get; }
        public System.Collections.Generic.IEnumerable<System.Reflection.PropertyInfo> SubjectProperties { get; }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.PropertyInfoSelectorAssertions> BeDecoratedWith<TAttribute>(string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.PropertyInfoSelectorAssertions> BeVirtual(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.PropertyInfoSelectorAssertions> BeWritable(string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.PropertyInfoSelectorAssertions> NotBeDecoratedWith<TAttribute>(string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.PropertyInfoSelectorAssertions> NotBeVirtual(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.PropertyInfoSelectorAssertions> NotBeWritable(string because = "", params object[] becauseArgs) { }
    }
    public class TypeAssertions : FluentAssertionsAsync.Primitives.ReferenceTypeAssertions<System.Type, FluentAssertionsAsync.Types.TypeAssertions>
    {
        public TypeAssertions(System.Type type) { }
        protected override string Identifier { get; }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> Be(System.Type expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> Be<TExpected>(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> BeAbstract(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> BeAssignableTo(System.Type type, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> BeAssignableTo<T>(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Types.TypeAssertions, TAttribute> BeDecoratedWith<TAttribute>(string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Types.TypeAssertions, TAttribute> BeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Types.TypeAssertions, TAttribute> BeDecoratedWithOrInherit<TAttribute>(string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Types.TypeAssertions, TAttribute> BeDecoratedWithOrInherit<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> BeDerivedFrom(System.Type baseType, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> BeDerivedFrom<TBaseClass>(string because = "", params object[] becauseArgs)
            where TBaseClass :  class { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> BeSealed(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> BeStatic(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> HaveAccessModifier(FluentAssertionsAsync.Common.CSharpAccessModifier accessModifier, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Types.TypeAssertions, System.Reflection.ConstructorInfo> HaveConstructor(System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Types.TypeAssertions, System.Reflection.ConstructorInfo> HaveDefaultConstructor(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Types.TypeAssertions, System.Reflection.MethodInfo> HaveExplicitConversionOperator(System.Type sourceType, System.Type targetType, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Types.TypeAssertions, System.Reflection.MethodInfo> HaveExplicitConversionOperator<TSource, TTarget>(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> HaveExplicitMethod(System.Type interfaceType, string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> HaveExplicitMethod<TInterface>(string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = "", params object[] becauseArgs)
            where TInterface :  class { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> HaveExplicitProperty(System.Type interfaceType, string name, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> HaveExplicitProperty<TInterface>(string name, string because = "", params object[] becauseArgs)
            where TInterface :  class { }
        public FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Types.TypeAssertions, System.Reflection.MethodInfo> HaveImplicitConversionOperator(System.Type sourceType, System.Type targetType, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Types.TypeAssertions, System.Reflection.MethodInfo> HaveImplicitConversionOperator<TSource, TTarget>(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Types.TypeAssertions, System.Reflection.PropertyInfo> HaveIndexer(System.Type indexerType, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Types.TypeAssertions, System.Reflection.MethodInfo> HaveMethod(string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Types.TypeAssertions, System.Reflection.PropertyInfo> HaveProperty(System.Type propertyType, string name, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Types.TypeAssertions, System.Reflection.PropertyInfo> HaveProperty<TProperty>(string name, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> Implement(System.Type interfaceType, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> Implement<TInterface>(string because = "", params object[] becauseArgs)
            where TInterface :  class { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> NotBe(System.Type unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> NotBe<TUnexpected>(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> NotBeAbstract(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> NotBeAssignableTo(System.Type type, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> NotBeAssignableTo<T>(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> NotBeDecoratedWith<TAttribute>(string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> NotBeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> NotBeDecoratedWithOrInherit<TAttribute>(string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> NotBeDecoratedWithOrInherit<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> NotBeDerivedFrom(System.Type baseType, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> NotBeDerivedFrom<TBaseClass>(string because = "", params object[] becauseArgs)
            where TBaseClass :  class { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> NotBeSealed(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> NotBeStatic(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> NotHaveAccessModifier(FluentAssertionsAsync.Common.CSharpAccessModifier accessModifier, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Types.TypeAssertions, System.Reflection.ConstructorInfo> NotHaveConstructor(System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Types.TypeAssertions, System.Reflection.ConstructorInfo> NotHaveDefaultConstructor(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> NotHaveExplicitConversionOperator(System.Type sourceType, System.Type targetType, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> NotHaveExplicitConversionOperator<TSource, TTarget>(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> NotHaveExplicitMethod(System.Type interfaceType, string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> NotHaveExplicitMethod<TInterface>(string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = "", params object[] becauseArgs)
            where TInterface :  class { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> NotHaveExplicitProperty(System.Type interfaceType, string name, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> NotHaveExplicitProperty<TInterface>(string name, string because = "", params object[] becauseArgs)
            where TInterface :  class { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> NotHaveImplicitConversionOperator(System.Type sourceType, System.Type targetType, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> NotHaveImplicitConversionOperator<TSource, TTarget>(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> NotHaveIndexer(System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> NotHaveMethod(string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> NotHaveProperty(string name, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> NotImplement(System.Type interfaceType, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeAssertions> NotImplement<TInterface>(string because = "", params object[] becauseArgs)
            where TInterface :  class { }
    }
    public class TypeSelector : System.Collections.Generic.IEnumerable<System.Type>, System.Collections.IEnumerable
    {
        public TypeSelector(System.Collections.Generic.IEnumerable<System.Type> types) { }
        public TypeSelector(System.Type type) { }
        public System.Collections.Generic.IEnumerator<System.Type> GetEnumerator() { }
        public FluentAssertionsAsync.Types.TypeSelector ThatAreAbstract() { }
        public FluentAssertionsAsync.Types.TypeSelector ThatAreClasses() { }
        public FluentAssertionsAsync.Types.TypeSelector ThatAreDecoratedWith<TAttribute>()
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.Types.TypeSelector ThatAreDecoratedWithOrInherit<TAttribute>()
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.Types.TypeSelector ThatAreInNamespace(string @namespace) { }
        public FluentAssertionsAsync.Types.TypeSelector ThatAreInterfaces() { }
        public FluentAssertionsAsync.Types.TypeSelector ThatAreNotAbstract() { }
        public FluentAssertionsAsync.Types.TypeSelector ThatAreNotClasses() { }
        public FluentAssertionsAsync.Types.TypeSelector ThatAreNotDecoratedWith<TAttribute>()
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.Types.TypeSelector ThatAreNotDecoratedWithOrInherit<TAttribute>()
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.Types.TypeSelector ThatAreNotInNamespace(string @namespace) { }
        public FluentAssertionsAsync.Types.TypeSelector ThatAreNotInterfaces() { }
        public FluentAssertionsAsync.Types.TypeSelector ThatAreNotSealed() { }
        public FluentAssertionsAsync.Types.TypeSelector ThatAreNotStatic() { }
        public FluentAssertionsAsync.Types.TypeSelector ThatAreNotUnderNamespace(string @namespace) { }
        public FluentAssertionsAsync.Types.TypeSelector ThatAreNotValueTypes() { }
        public FluentAssertionsAsync.Types.TypeSelector ThatAreSealed() { }
        public FluentAssertionsAsync.Types.TypeSelector ThatAreStatic() { }
        public FluentAssertionsAsync.Types.TypeSelector ThatAreUnderNamespace(string @namespace) { }
        public FluentAssertionsAsync.Types.TypeSelector ThatAreValueTypes() { }
        public FluentAssertionsAsync.Types.TypeSelector ThatDeriveFrom<TBase>() { }
        public FluentAssertionsAsync.Types.TypeSelector ThatDoNotDeriveFrom<TBase>() { }
        public FluentAssertionsAsync.Types.TypeSelector ThatDoNotImplement<TInterface>() { }
        public FluentAssertionsAsync.Types.TypeSelector ThatImplement<TInterface>() { }
        public FluentAssertionsAsync.Types.TypeSelector ThatSatisfy(System.Func<System.Type, bool> predicate) { }
        public System.Type[] ToArray() { }
        public FluentAssertionsAsync.Types.TypeSelector UnwrapEnumerableTypes() { }
        public FluentAssertionsAsync.Types.TypeSelector UnwrapTaskTypes() { }
    }
    public class TypeSelectorAssertions
    {
        public TypeSelectorAssertions(params System.Type[] types) { }
        public System.Collections.Generic.IEnumerable<System.Type> Subject { get; }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeSelectorAssertions> BeDecoratedWith<TAttribute>(string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeSelectorAssertions> BeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeSelectorAssertions> BeDecoratedWithOrInherit<TAttribute>(string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeSelectorAssertions> BeDecoratedWithOrInherit<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeSelectorAssertions> BeInNamespace(string @namespace, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeSelectorAssertions> BeSealed(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeSelectorAssertions> BeUnderNamespace(string @namespace, string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeSelectorAssertions> NotBeDecoratedWith<TAttribute>(string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeSelectorAssertions> NotBeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeSelectorAssertions> NotBeDecoratedWithOrInherit<TAttribute>(string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeSelectorAssertions> NotBeDecoratedWithOrInherit<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeSelectorAssertions> NotBeInNamespace(string @namespace, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeSelectorAssertions> NotBeSealed(string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Types.TypeSelectorAssertions> NotBeUnderNamespace(string @namespace, string because = "", params object[] becauseArgs) { }
    }
}
namespace FluentAssertionsAsync.Xml
{
    public class XAttributeAssertions : FluentAssertionsAsync.Primitives.ReferenceTypeAssertions<System.Xml.Linq.XAttribute, FluentAssertionsAsync.Xml.XAttributeAssertions>
    {
        public XAttributeAssertions(System.Xml.Linq.XAttribute attribute) { }
        protected override string Identifier { get; }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Xml.XAttributeAssertions> Be(System.Xml.Linq.XAttribute expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Xml.XAttributeAssertions> HaveValue(string expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Xml.XAttributeAssertions> NotBe(System.Xml.Linq.XAttribute unexpected, string because = "", params object[] becauseArgs) { }
    }
    public class XDocumentAssertions : FluentAssertionsAsync.Primitives.ReferenceTypeAssertions<System.Xml.Linq.XDocument, FluentAssertionsAsync.Xml.XDocumentAssertions>
    {
        public XDocumentAssertions(System.Xml.Linq.XDocument document) { }
        protected override string Identifier { get; }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Xml.XDocumentAssertions> Be(System.Xml.Linq.XDocument expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Xml.XDocumentAssertions> BeEquivalentTo(System.Xml.Linq.XDocument expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Xml.XDocumentAssertions, System.Xml.Linq.XElement> HaveElement(string expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Xml.XDocumentAssertions, System.Xml.Linq.XElement> HaveElement(System.Xml.Linq.XName expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Xml.XDocumentAssertions, System.Collections.Generic.IEnumerable<System.Xml.Linq.XElement>> HaveElement(string expected, FluentAssertionsAsync.OccurrenceConstraint occurrenceConstraint, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Xml.XDocumentAssertions, System.Collections.Generic.IEnumerable<System.Xml.Linq.XElement>> HaveElement(System.Xml.Linq.XName expected, FluentAssertionsAsync.OccurrenceConstraint occurrenceConstraint, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Xml.XDocumentAssertions, System.Xml.Linq.XElement> HaveRoot(string expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Xml.XDocumentAssertions, System.Xml.Linq.XElement> HaveRoot(System.Xml.Linq.XName expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Xml.XDocumentAssertions> NotBe(System.Xml.Linq.XDocument unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Xml.XDocumentAssertions> NotBeEquivalentTo(System.Xml.Linq.XDocument unexpected, string because = "", params object[] becauseArgs) { }
    }
    public class XElementAssertions : FluentAssertionsAsync.Primitives.ReferenceTypeAssertions<System.Xml.Linq.XElement, FluentAssertionsAsync.Xml.XElementAssertions>
    {
        public XElementAssertions(System.Xml.Linq.XElement xElement) { }
        protected override string Identifier { get; }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Xml.XElementAssertions> Be(System.Xml.Linq.XElement expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Xml.XElementAssertions> BeEquivalentTo(System.Xml.Linq.XElement expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Xml.XElementAssertions> HaveAttribute(string expectedName, string expectedValue, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Xml.XElementAssertions> HaveAttribute(System.Xml.Linq.XName expectedName, string expectedValue, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Xml.XElementAssertions, System.Xml.Linq.XElement> HaveElement(string expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Xml.XElementAssertions, System.Xml.Linq.XElement> HaveElement(System.Xml.Linq.XName expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Xml.XElementAssertions, System.Collections.Generic.IEnumerable<System.Xml.Linq.XElement>> HaveElement(string expected, FluentAssertionsAsync.OccurrenceConstraint occurrenceConstraint, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Xml.XElementAssertions, System.Collections.Generic.IEnumerable<System.Xml.Linq.XElement>> HaveElement(System.Xml.Linq.XName expected, FluentAssertionsAsync.OccurrenceConstraint occurrenceConstraint, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Xml.XElementAssertions> HaveValue(string expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Xml.XElementAssertions> NotBe(System.Xml.Linq.XElement unexpected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Xml.XElementAssertions> NotBeEquivalentTo(System.Xml.Linq.XElement unexpected, string because = "", params object[] becauseArgs) { }
    }
    public class XmlElementAssertions : FluentAssertionsAsync.Xml.XmlNodeAssertions<System.Xml.XmlElement, FluentAssertionsAsync.Xml.XmlElementAssertions>
    {
        public XmlElementAssertions(System.Xml.XmlElement xmlElement) { }
        protected override string Identifier { get; }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Xml.XmlElementAssertions> HaveAttribute(string expectedName, string expectedValue, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Xml.XmlElementAssertions> HaveAttributeWithNamespace(string expectedName, string expectedNamespace, string expectedValue, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Xml.XmlElementAssertions, System.Xml.XmlElement> HaveElement(string expectedName, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndWhichConstraint<FluentAssertionsAsync.Xml.XmlElementAssertions, System.Xml.XmlElement> HaveElementWithNamespace(string expectedName, string expectedNamespace, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<FluentAssertionsAsync.Xml.XmlElementAssertions> HaveInnerText(string expected, string because = "", params object[] becauseArgs) { }
    }
    public class XmlNodeAssertions : FluentAssertionsAsync.Xml.XmlNodeAssertions<System.Xml.XmlNode, FluentAssertionsAsync.Xml.XmlNodeAssertions>
    {
        public XmlNodeAssertions(System.Xml.XmlNode xmlNode) { }
    }
    public class XmlNodeAssertions<TSubject, TAssertions> : FluentAssertionsAsync.Primitives.ReferenceTypeAssertions<TSubject, TAssertions>
        where TSubject : System.Xml.XmlNode
        where TAssertions : FluentAssertionsAsync.Xml.XmlNodeAssertions<TSubject, TAssertions>
    {
        public XmlNodeAssertions(TSubject xmlNode) { }
        protected override string Identifier { get; }
        public FluentAssertionsAsync.AndConstraint<TAssertions> BeEquivalentTo(System.Xml.XmlNode expected, string because = "", params object[] becauseArgs) { }
        public FluentAssertionsAsync.AndConstraint<TAssertions> NotBeEquivalentTo(System.Xml.XmlNode unexpected, string because = "", params object[] becauseArgs) { }
    }
    public class XmlNodeFormatter : FluentAssertionsAsync.Formatting.IValueFormatter
    {
        public XmlNodeFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, FluentAssertionsAsync.Formatting.FormattedObjectGraph formattedGraph, FluentAssertionsAsync.Formatting.FormattingContext context, FluentAssertionsAsync.Formatting.FormatChild formatChild) { }
    }
}